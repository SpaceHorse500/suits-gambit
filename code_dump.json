{
  "root": "C:\\Users\\Ezana\\Documents\\Suits_Gambit",
  "count": 35,
  "files": [
    {
      "path": "aggregator.py",
      "content": "#!/usr/bin/env python3\n\"\"\"\nbundle_py_to_json.py\n\nRecursively collect all .py files under a root directory and dump them\nto a JSON file as a list of { \"path\": <relative path>, \"content\": <file text> }.\n\nUsage:\n  python bundle_py_to_json.py --root . --out code_dump.json\n  python bundle_py_to_json.py --root C:/Users/Me/project --out project_code.json \\\n      --exclude .git __pycache__ venv .venv dist build .mypy_cache .pytest_cache\n\nNotes:\n- Reads files as UTF-8 with errors='replace' so it never crashes on encoding.\n- Skips common junk dirs by default; add more with --exclude.\n\"\"\"\n\nimport argparse\nimport json\nimport os\nfrom pathlib import Path\nfrom typing import Iterable, List, Dict, Any\n\nDEFAULT_EXCLUDES = {\n    \".git\", \"__pycache__\", \"venv\", \".venv\", \"env\", \".env\",\n    \"build\", \"dist\", \".mypy_cache\", \".pytest_cache\", \".idea\", \".vscode\",\n    \".tox\", \".ruff_cache\", \".coverage\", \".gitlab\", \".github\"\n}\n\ndef iter_py_files(root: Path, exclude_dirs: Iterable[str]) -> Iterable[Path]:\n    exclude = set(exclude_dirs)\n    for dirpath, dirnames, filenames in os.walk(root):\n        # prune excluded directories in-place so os.walk doesn't descend into them\n        dirnames[:] = [d for d in dirnames if d not in exclude]\n        for fn in filenames:\n            if fn.endswith(\".py\"):\n                yield Path(dirpath) / fn\n\ndef read_text_safe(p: Path) -> str:\n    # Normalize newlines and tolerate odd encodings\n    with p.open(\"r\", encoding=\"utf-8\", errors=\"replace\") as f:\n        return f.read().replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n\ndef bundle(root: Path, out_path: Path, exclude_dirs: Iterable[str]) -> Dict[str, Any]:\n    files: List[Dict[str, str]] = []\n    for p in sorted(iter_py_files(root, exclude_dirs)):\n        rel = p.relative_to(root).as_posix()\n        try:\n            content = read_text_safe(p)\n        except Exception as e:\n            content = f\"<<ERROR READING FILE: {e}>>\"\n        files.append({\"path\": rel, \"content\": content})\n    payload: Dict[str, Any] = {\n        \"root\": str(root.resolve()),\n        \"count\": len(files),\n        \"files\": files,\n    }\n    # Write JSON\n    out_path.parent.mkdir(parents=True, exist_ok=True)\n    with out_path.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(payload, f, ensure_ascii=False, indent=2)\n    return payload\n\ndef main():\n    ap = argparse.ArgumentParser(description=\"Bundle .py files into a JSON archive.\")\n    ap.add_argument(\"--root\", type=Path, default=Path(\".\"), help=\"Root directory to scan\")\n    ap.add_argument(\"--out\", type=Path, default=Path(\"code_dump.json\"), help=\"Output JSON file\")\n    ap.add_argument(\n        \"--exclude\", nargs=\"*\", default=sorted(DEFAULT_EXCLUDES),\n        help=\"Directory names to exclude (not paths; exact folder names).\"\n    )\n    args = ap.parse_args()\n\n    payload = bundle(args.root, args.out, args.exclude)\n    print(f\"Wrote {payload['count']} files to {args.out}\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "path": "cards.py",
      "content": "# cards.py\nfrom dataclasses import dataclass\nimport random\nfrom typing import List, Optional, Dict\n\nSUITS = [\"♣\", \"♦\", \"♥\", \"♠\"]\nRANKS = [\"A\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\"]\n\n@dataclass(frozen=True)\nclass Card:\n    suit: str\n    rank: str\n\nclass Deck:\n    def __init__(self, seed: Optional[int] = None):\n        self._seed = seed\n        self.cards: List[Card] = []\n        # Store suit counts to avoid re-calculating\n        self._remaining_suits: Dict[str, int] = {s: 0 for s in SUITS}\n        self.reset()\n\n    def reset(self):\n        if self._seed is not None:\n            random.seed(self._seed)\n        self.cards = [Card(s, r) for s in SUITS for r in RANKS]\n        random.shuffle(self.cards)\n        # Recalculate suit counts after reset\n        self._remaining_suits = {s: 13 for s in SUITS}\n\n    def draw(self) -> Optional[Card]:\n        if not self.cards:\n            return None\n        card = self.cards.pop()\n        self._remaining_suits[card.suit] -= 1\n        return card\n\n    def remaining(self) -> int:\n        return len(self.cards)\n\n    def remaining_by_suit(self) -> Dict[str, int]:\n        # Return the pre-calculated counts instead of iterating\n        return self._remaining_suits"
    },
    {
      "path": "eva_pods.py",
      "content": "#!/usr/bin/env python3\n# eva_pods.py\nfrom __future__ import annotations\nimport argparse, copy, json, math, os, random, statistics\nfrom typing import Any, Dict, List, Tuple\n\n# --- Pod evaluator ---\nfrom ga.pod_evaluator import PodEloEvaluator\n\n# Try to use your Genome class if it exists, but don't require .random()\ntry:\n    from ga.ga_genome import Genome  # only for type hints / optional usage\nexcept Exception:\n    Genome = Any  # type: ignore\n\n\n# --- A tiny wrapper so EvoPlayer can consume .to_json() as usual ---\nclass SimpleGenome:\n    def __init__(self, payload: Dict[str, Any]):\n        self.payload = payload\n\n    def to_json(self) -> Dict[str, Any]:\n        \"\"\"\n        IMPORTANT: Return a dict (not a JSON string), so EvoPlayer receives\n        a mapping and can do self.g[\"forbidden\"], etc.\n        \"\"\"\n        return copy.deepcopy(self.payload)\n\n\ndef _load_baseline(path: str = \"weights.json\") -> Dict[str, Any]:\n    if not os.path.exists(path):\n        raise FileNotFoundError(\n            f\"Could not find '{path}'. Put a baseline genome file there \"\n            \"(your repo already has weights.json).\"\n        )\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n\n\ndef _jitter_number(key: str, val: float, rng: random.Random, frac: float) -> float:\n    \"\"\"Gaussian jitter by (frac * scale). Clamps 'prob-like' keys to [0,1].\"\"\"\n    scale = abs(val) + 1e-6\n    new_val = val + rng.gauss(0.0, frac * scale)\n\n    # Heuristics: clamp some probability-like knobs into [0,1]\n    k = key.lower()\n    if any(s in k for s in (\"prob\", \"repeat\", \"prefer\")):\n        new_val = max(0.0, min(1.0, new_val))\n\n    # Mildly clamp tiny thresholds from going very negative\n    if \"threshold\" in k:\n        new_val = max(-10.0, min(10.0, new_val))\n\n    return new_val\n\n\ndef _jitter_int(key: str, val: int, rng: random.Random, step: int = 1, lo: int = 0, hi: int = 10) -> int:\n    \"\"\"Small integer tweaks, clamped to a reasonable band.\"\"\"\n    delta = rng.choice([-1, 0, +1])\n    out = int(val + delta * step)\n    return max(lo, min(hi, out))\n\n\ndef _jitter_dict(d: Dict[str, Any], rng: random.Random, frac: float) -> Dict[str, Any]:\n    \"\"\"Deep-copy + jitter numbers; keep structure & keys the same.\"\"\"\n    out: Dict[str, Any] = {}\n    for k, v in d.items():\n        if isinstance(v, dict):\n            out[k] = _jitter_dict(v, rng, frac)\n        elif isinstance(v, (list, tuple)):\n            # Jitter numeric elements but preserve length/order\n            new_list = []\n            for idx, el in enumerate(v):\n                if isinstance(el, (int, float)):\n                    j = _jitter_number(f\"{k}[{idx}]\", float(el), rng, frac)\n                    # restore int where it was int-ish\n                    if isinstance(el, int):\n                        j = int(round(j))\n                    new_list.append(j)\n                else:\n                    new_list.append(el)\n            out[k] = type(v)(new_list)\n        elif isinstance(v, float):\n            out[k] = _jitter_number(k, v, rng, frac)\n        elif isinstance(v, int):\n            out[k] = _jitter_int(k, v, rng, lo=0, hi=12)\n        else:\n            out[k] = v\n    return out\n\n\ndef build_population_from_weights(\n    size: int,\n    baseline_path: str = \"weights.json\",\n    seed: int = 1234,\n    jitter_frac: float = 0.25,\n) -> List[SimpleGenome]:\n    \"\"\"\n    Make 'size' genomes by jittering the baseline weights.json.\n    jitter_frac ~ 0.25 = 25% Gaussian noise relative to |value|.\n    \"\"\"\n    rng = random.Random(seed)\n    base = _load_baseline(baseline_path)\n    pop: List[SimpleGenome] = []\n    for _ in range(size):\n        g = _jitter_dict(base, rng, jitter_frac)\n        pop.append(SimpleGenome(g))\n    return pop\n\n\ndef maybe_use_genome_random(size: int) -> List[Any]:\n    \"\"\"\n    If your Genome class has a random-like constructor, you can use it here.\n    Otherwise we fall back to jittering weights.json.\n    \"\"\"\n    # Try common patterns without hard-failing.\n    ctor_names = [\"random\", \"rand\", \"sample\", \"from_random\"]\n    for name in ctor_names:\n        if hasattr(Genome, name) and callable(getattr(Genome, name)):\n            ctor = getattr(Genome, name)\n            return [ctor() for _ in range(size)]  # type: ignore\n    # Fallback to weights.json jitter\n    return build_population_from_weights(size)\n\n\ndef main():\n    ap = argparse.ArgumentParser(description=\"Evaluate genomes in 5-player pods (Elo-based).\")\n    ap.add_argument(\"--pop\", type=int, default=24, help=\"Population size (genomes)\")\n    ap.add_argument(\"--rounds\", type=int, default=120, help=\"Scheduling rounds (pods per round)\")\n    ap.add_argument(\"--seed\", type=int, default=42, help=\"Base RNG seed\")\n    ap.add_argument(\"--pod-size\", type=int, default=5, help=\"Players per game (default 5)\")\n    ap.add_argument(\"--k\", type=float, default=24.0, help=\"Elo K-factor\")\n    ap.add_argument(\"--verbose-game\", type=int, default=0, help=\"0/1/2 matches your engine verbosity\")\n    ap.add_argument(\"--jitter\", type=float, default=0.25, help=\"If using weights.json jitter, relative stddev\")\n    args = ap.parse_args()\n\n    # Build population robustly\n    try:\n        pop = maybe_use_genome_random(args.pop)\n    except Exception:\n        # Guaranteed path: jitter weights.json\n        pop = build_population_from_weights(args.pop, jitter_frac=args.jitter, seed=args.seed)\n\n    evaluator = PodEloEvaluator(pod_size=args.pod_size, k_factor=args.k)\n    fits, control = evaluator.evaluate(\n        pop,\n        rounds=args.rounds,\n        base_seed=args.seed,\n        verbose_game=args.verbose_game,\n    )\n\n    # Leaderboard by Elo\n    leaderboard = sorted(\n        [\n            (i, f.diagnostics.get(\"elo\", 0.0), f.win_rate,\n             f.diagnostics.get(\"rank_mean\", float(\"inf\")),\n             f.diagnostics.get(\"bust_rate\", float(\"nan\")),\n             f.diagnostics.get(\"rank_points\", 0.0))\n            for i, f in enumerate(fits)\n        ],\n        key=lambda t: t[1],\n        reverse=True,\n    )[:12]\n\n    print(\"\\n=== POD EVALUATION (pods of {}) ===\".format(args.pod_size))\n    print(\"Top by Elo:\")\n    for i, elo, wr, rmean, br, rpts in leaderboard:\n        print(f\"Evo{i:02d} | Elo {elo:6.1f} | win% {wr*100:5.2f} | E[rank] {rmean:4.2f} | \"\n              f\"rankPts {rpts:4.2f} | bust% {br*100:5.1f}\")\n\n    meta = control[\"Meta\"]\n    print(f\"\\nMeta | Elo {meta.diagnostics['elo']:.1f} | win% {meta.win_rate*100:.2f} \"\n          f\"| median {meta.median:.1f} | games {meta.diagnostics['n_games']}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "path": "eval_bots.py",
      "content": "import os\nimport json\nimport argparse\nimport random\nimport statistics as stats\nimport math\nfrom collections import defaultdict, Counter\nfrom typing import Dict, List, Tuple, Any, Callable\n\n# ANSI color codes\nclass Colors:\n    HEADER = '\\033[95m'\n    BLUE = '\\033[94m'\n    CYAN = '\\033[96m'\n    GREEN = '\\033[92m'\n    YELLOW = '\\033[93m'\n    RED = '\\033[91m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n    END = '\\033[0m'\n\n# Project imports\nfrom evo_player import EvoPlayer\nfrom game import SuitsGambitGame\nfrom ga.ga_controls import ControlPool\n\n# =========================\n# Enhanced Statistics Helpers\n# =========================\ndef iqr(values: List[float]) -> float:\n    \"\"\"Calculate interquartile range\"\"\"\n    if not values:\n        return 0.0\n    xs = sorted(values)\n    q1 = xs[len(xs)//4]\n    q3 = xs[(3*len(xs))//4]\n    return float(q3 - q1)\n\ndef cliffs_delta(a: List[float], b: List[float]) -> float:\n    \"\"\"Effect size measure for ordinal data\"\"\"\n    gt = sum(1 for x, y in zip(a, b) if x > y)\n    lt = sum(1 for x, y in zip(a, b) if x < y)\n    n = gt + lt\n    return 0.0 if n == 0 else (gt - lt) / n\n\ndef zeroed_multiplicative_block(scores: List[int], ops: List[str]) -> bool:\n    \"\"\"Check if any ×-block contains a zero\"\"\"\n    cur_zero = (scores[0] == 0)\n    for i, op in enumerate(ops, start=1):\n        if op == \"x\":\n            cur_zero = cur_zero or (scores[i] == 0)\n        else:\n            if cur_zero:\n                return True\n            cur_zero = (scores[i] == 0)\n    return cur_zero\n\n# =========================\n# Simulation with Advanced Telemetry\n# =========================\ndef simulate_tournament(\n    evo_bots: List[Tuple[str, Dict[str, Any]]],\n    include_controls: bool = True,\n    games: int = 5000,\n    seed: int = 123,\n    game_verbose: int = 0,\n) -> Dict[str, Any]:\n    \"\"\"Run tournament with advanced statistics tracking\"\"\"\n    # Create players\n    evos_players = [EvoPlayer(name, genome=g) for name, g in evo_bots]\n    control_players = ControlPool().make() if include_controls else []\n    all_players = evos_players + control_players\n    \n    # Initialize trackers\n    totals_hist = defaultdict(list)\n    wins = Counter()\n    ties = 0\n    bust_rounds = Counter()\n    pre_bust_sum = Counter()\n    rounds_played = Counter()\n    stop_at_two = Counter()\n    plus_count = Counter()\n    times_count = Counter()\n    x_after_x = Counter()\n    zeroed_block_games = Counter()\n    stop_counts = Counter()\n    stop_counts_by_op = Counter()\n    stop_counts_by_round = Counter()\n    per_game_totals = []\n\n    # Run simulations\n    for gidx in range(games):\n        rng = random.Random(seed + gidx)\n        players = list(all_players)\n        rng.shuffle(players)\n\n        game = SuitsGambitGame(players, verbose=game_verbose, seed=seed + gidx)\n        winner, results = game.play()\n\n        # Record results\n        per_game_totals.append(results)\n        if winner is None:\n            ties += 1\n        else:\n            wins[winner] += 1\n\n        for p in players:\n            name = p.name\n            totals_hist[name].append(results[name])\n            \n            # Round-level statistics\n            for r, score in enumerate(p.round_scores):\n                rounds_played[name] += 1\n                if score == 0:\n                    bust_rounds[name] += 1\n                    pb = getattr(p, \"pre_bust\", [None]*5)[r]\n                    if pb is not None:\n                        pre_bust_sum[name] += pb\n                if score == 2:\n                    stop_at_two[name] += 1\n                \n                # Track stop counts\n                if score > 0:\n                    K = score\n                    stop_counts[(name, K)] += 1\n                    op_ctx = \"+\" if r == 0 else p.ops_between[r-1] if r-1 < len(p.ops_between) else \"+\"\n                    stop_counts_by_op[(name, op_ctx, K)] += 1\n                    stop_counts_by_round[(name, r+1, K)] += 1\n\n            # Operator statistics\n            ops = p.ops_between\n            plus_count[name] += sum(1 for o in ops if o == '+')\n            times_count[name] += sum(1 for o in ops if o == 'x')\n            for a, b in zip(ops, ops[1:]):\n                if a == 'x' and b == 'x':\n                    x_after_x[name] += 1\n\n            if zeroed_multiplicative_block(p.round_scores, ops):\n                zeroed_block_games[name] += 1\n\n    return {\n        \"summaries\": {\n            name: {\n                \"games\": games,\n                \"median\": float(stats.median(totals_hist[name])),\n                \"mean\": float(stats.mean(totals_hist[name])),\n                \"sd\": float(stats.pstdev(totals_hist[name])) if len(totals_hist[name]) > 1 else 0.0,\n                \"win_rate\": wins[name] / games,\n                \"max\": max(totals_hist[name]),\n                \"min\": min(totals_hist[name]),\n                \"bust_rate\": bust_rounds[name] / rounds_played[name] if rounds_played[name] else 0.0,\n                \"iqr\": iqr(totals_hist[name]),\n                \"wins\": wins[name],\n                \"avg_pre_bust\": pre_bust_sum[name] / bust_rounds[name] if bust_rounds[name] else 0.0,\n                \"stop2_rate\": stop_at_two[name] / rounds_played[name] if rounds_played[name] else 0.0,\n                \"x_pct\": times_count[name] / (plus_count[name] + times_count[name]) if (plus_count[name] + times_count[name]) else 0.0,\n                \"xchain_rate\": x_after_x[name] / (games * 3),  # 3 op pairs per game\n                \"zeroed_rate\": zeroed_block_games[name] / games,\n            }\n            for name in totals_hist\n        },\n        \"per_game_totals\": per_game_totals,\n        \"ties\": ties,\n        \"games\": games,\n        \"table_size\": len(all_players),\n        \"baseline\": 1.0 / len(all_players) if all_players else 0.0,\n        \"evo_names\": [p.name for p in evos_players],\n        \"control_names\": [p.name for p in control_players],\n        \"stop_counts\": stop_counts,\n        \"stop_counts_by_op\": stop_counts_by_op,\n        \"stop_counts_by_round\": stop_counts_by_round,\n    }\n\n# =========================\n# Enhanced Reporting with Colors\n# =========================\ndef print_section_header(title: str, color: str = Colors.CYAN):\n    \"\"\"Print a formatted section header\"\"\"\n    print(f\"\\n{color}{Colors.BOLD}=== {title.upper()} ==={Colors.END}\")\n\ndef print_subsection_header(title: str, color: str = Colors.YELLOW):\n    \"\"\"Print a formatted subsection header\"\"\"\n    print(f\"\\n{color}{Colors.UNDERLINE}— {title} —{Colors.END}\")\n\ndef colorize_number(value: float, reverse: bool = False, fmt: str = \".2f\") -> str:\n    \"\"\"Color code numbers based on their value, preserving formatting\"\"\"\n    if isinstance(value, str):\n        return value\n    \n    formatted_value = format(value, fmt)\n    \n    if reverse:\n        # For values where lower is better (like bust rate)\n        if value > 0.5: return f\"{Colors.RED}{formatted_value}{Colors.END}\"\n        if value > 0.3: return f\"{Colors.YELLOW}{formatted_value}{Colors.END}\"\n        return f\"{Colors.GREEN}{formatted_value}{Colors.END}\"\n    else:\n        # For values where higher is better (like win rate)\n        if value > 0.5: return f\"{Colors.GREEN}{formatted_value}{Colors.END}\"\n        if value > 0.3: return f\"{Colors.YELLOW}{formatted_value}{Colors.END}\"\n        return f\"{Colors.RED}{formatted_value}{Colors.END}\"\n\ndef print_advanced_report(result: Dict[str, Any]):\n    \"\"\"Print comprehensive analysis with colorful formatting\"\"\"\n    summaries = result[\"summaries\"]\n    games = result[\"games\"]\n    baseline = result[\"baseline\"]\n    evo_names = set(result[\"evo_names\"])\n    control_names = set(result[\"control_names\"])\n\n    # Rank by win rate\n    ranked = sorted(summaries.keys(),\n                   key=lambda n: (summaries[n][\"win_rate\"], summaries[n][\"median\"], summaries[n][\"mean\"]),\n                   reverse=True)\n\n    print_section_header(f\"Advanced Evaluation: {games} games | Table Size={result['table_size']} | Baseline Win≈{100*baseline:.2f}%\")\n\n    # Main performance metrics\n    print_subsection_header(\"Performance Summary\")\n    for name in ranked:\n        s = summaries[name]\n        win_mult = s['win_rate']/baseline if baseline > 0 else 0.0\n        print(f\"{Colors.BOLD}{name:24s}{Colors.END} | \"\n              f\"med {colorize_number(s['median'], fmt='5.2f')} | \"\n              f\"avg {colorize_number(s['mean'], fmt='5.2f')} | \"\n              f\"sd {s['sd']:5.2f} | \"\n              f\"win% {colorize_number(100*s['win_rate'], fmt='5.2f')} ({colorize_number(win_mult, fmt='4.2f')}×) | \"\n              f\"max {Colors.BOLD}{s['max']:3d}{Colors.END} | min {s['min']:3d} | \"\n              f\"bust% {colorize_number(100*s['bust_rate'], reverse=True, fmt='5.2f')} | \"\n              f\"IQR {s['iqr']:5.2f}\")\n\n    # Behavioral profiles\n    print_subsection_header(\"Behavioral Profiles\")\n    for name in ranked:\n        s = summaries[name]\n        \n        # Style classification\n        style_parts = []\n        if s['x_pct'] < 0.4:\n            style_parts.append(f\"{Colors.BLUE}additive{Colors.END}\")\n        elif s['x_pct'] > 0.6:\n            style_parts.append(f\"{Colors.RED}multiplier{Colors.END}\")\n        else:\n            style_parts.append(f\"{Colors.GREEN}balanced{Colors.END}\")\n            \n        if s['bust_rate'] > 0.45:\n            style_parts.append(f\"{Colors.RED}risky{Colors.END}\")\n        elif s['bust_rate'] < 0.35:\n            style_parts.append(f\"{Colors.GREEN}safe{Colors.END}\")\n        else:\n            style_parts.append(f\"{Colors.YELLOW}moderate{Colors.END}\")\n            \n        if s['stop2_rate'] > 0.08:\n            style_parts.append(f\"{Colors.CYAN}banks@2{Colors.END}\")\n        else:\n            style_parts.append(\"rare@2\")\n        \n        print(f\"{Colors.BOLD}{name:24s}{Colors.END} | \"\n              f\"bust {colorize_number(100*s['bust_rate'], reverse=True, fmt='5.1f')}% | \"\n              f\"pre-bust {colorize_number(s['avg_pre_bust'], fmt='4.2f')} | \"\n              f\"ops: +/{colorize_number(s['x_pct'], fmt='.1%')}× | \"\n              f\"chains {colorize_number(100*s['xchain_rate'], fmt='4.1f')}% | \"\n              f\"zeroed {colorize_number(100*s['zeroed_rate'], reverse=True, fmt='4.1f')}% | \"\n              f\"style: {', '.join(style_parts)}\")\n\n    # Pairwise comparisons\n    print_subsection_header(\"Pairwise Performance\")\n    cols = {n: [g[n] for g in result[\"per_game_totals\"]] for n in summaries}\n    header = \" \" * 24 + \" \".join([f\"{Colors.BOLD}{n[:10]:>10s}{Colors.END}\" for n in ranked])\n    print(header)\n    for a in ranked:\n        row = [f\"{Colors.BOLD}{a:24s}{Colors.END}\"]\n        for b in ranked:\n            if a == b:\n                row.append(f\"{'-':>10s}\")\n                continue\n            aw = sum(1 for x, y in zip(cols[a], cols[b]) if x > y)\n            al = sum(1 for x, y in zip(cols[a], cols[b]) if x < y)\n            n = aw + al\n            wr = aw / n if n else 0.0\n            d = cliffs_delta(cols[a], cols[b])\n            \n            # Color based on win rate\n            if wr > 0.6:\n                wr_str = f\"{Colors.GREEN}{100*wr:5.1f}%{Colors.END}\"\n            elif wr < 0.4:\n                wr_str = f\"{Colors.RED}{100*wr:5.1f}%{Colors.END}\"\n            else:\n                wr_str = f\"{Colors.YELLOW}{100*wr:5.1f}%{Colors.END}\"\n                \n            # Color based on effect size\n            if abs(d) > 0.4:\n                d_str = f\"{Colors.GREEN if d > 0 else Colors.RED}{d:+.2f}{Colors.END}\"\n            elif abs(d) > 0.2:\n                d_str = f\"{Colors.YELLOW}{d:+.2f}{Colors.END}\"\n            else:\n                d_str = f\"{d:+.2f}\"\n                \n            row.append(f\"{wr_str}/{d_str}\")\n        print(\" \".join(row))\n\n    # Stop behavior analysis\n    print_subsection_header(\"Stop Behavior Analysis\")\n    kset = sorted({k for (n, k) in result[\"stop_counts\"] if result[\"stop_counts\"][(n, k)] > 0})\n    for name in ranked:\n        stops = [result[\"stop_counts\"].get((name, k), 0) for k in kset]\n        stop_strs = []\n        for k, cnt in zip(kset, stops):\n            if cnt > 0:\n                if cnt > games * 0.1:  # Highlight frequent stops\n                    stop_strs.append(f\"@{k}:{Colors.GREEN}{cnt:3d}{Colors.END}\")\n                else:\n                    stop_strs.append(f\"@{k}:{cnt:3d}\")\n        print(f\"{Colors.BOLD}{name:24s}{Colors.END} | \" + \" \".join(stop_strs))\n\n    # Final summary\n    print_section_header(\"Evaluation Complete\", Colors.GREEN)\n    print(f\"\\n{Colors.BOLD}Key:{Colors.END}\")\n    print(f\"{Colors.GREEN}Green{Colors.END} = Good performance/safe behavior\")\n    print(f\"{Colors.YELLOW}Yellow{Colors.END} = Moderate performance\")\n    print(f\"{Colors.RED}Red{Colors.END} = Poor performance/risky behavior\")\n    print(f\"{Colors.BLUE}Blue{Colors.END} = Additive playstyle\")\n    print(f\"{Colors.RED}Red{Colors.END} = Multiplier playstyle\")\n    print(f\"{Colors.GREEN}Green{Colors.END} = Balanced playstyle\")\n\n# =========================\n# Main Execution\n# =========================\ndef load_saved_bots(folder: str) -> List[Tuple[str, Dict[str, Any]]]:\n    \"\"\"Load bot genomes from JSON files\"\"\"\n    items = []\n    if not os.path.isdir(folder):\n        print(f\"{Colors.RED}[WARN] Bots folder not found: {folder}{Colors.END}\")\n        return items\n\n    for fname in sorted(os.listdir(folder)):\n        if not fname.lower().endswith(\".json\"):\n            continue\n        fpath = os.path.join(folder, fname)\n        try:\n            with open(fpath, \"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n                genome = data.get(\"genome\", data)  # Support both wrapped and raw genomes\n                if not isinstance(genome, dict):\n                    continue\n                \n                # Extract timestamp from filename\n                timestamp = fname.split('_')[-1].split('.')[0]\n                name = f\"EvoGen{fname[3:6]}@{timestamp}\"  # Convert gen005... to EvoGen005@...\n                items.append((name, genome))\n        except Exception as e:\n            print(f\"{Colors.YELLOW}[WARN] Skipping {fname}: {e}{Colors.END}\")\n\n    return items\n\ndef main():\n    ap = argparse.ArgumentParser(description=\"Advanced evaluation of good bots\")\n    ap.add_argument(\"--folder\", default=\"good_bots\", help=\"Folder containing good bot JSONs\")\n    ap.add_argument(\"--games\", type=int, default=5000, help=\"Number of games to simulate\")\n    ap.add_argument(\"--seed\", type=int, default=123, help=\"RNG seed\")\n    ap.add_argument(\"--no-controls\", action=\"store_true\", help=\"Exclude control bots\")\n    args = ap.parse_args()\n\n    print(f\"\\n{Colors.HEADER}{Colors.BOLD}=== Suits Gambit Bot Evaluator ==={Colors.END}\\n\")\n    \n    bots = load_saved_bots(args.folder)\n    if not bots:\n        print(f\"{Colors.RED}No saved bots found in {args.folder}.{Colors.END}\")\n        return\n\n    print(f\"{Colors.GREEN}Loaded {len(bots)} bots from {args.folder}{Colors.END}\")\n\n    res = simulate_tournament(\n        evo_bots=bots,\n        include_controls=not args.no_controls,\n        games=args.games,\n        seed=args.seed,\n        game_verbose=0\n    )\n\n    print_advanced_report(res)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "path": "evo_io.py",
      "content": "# evo_io.py\nfrom __future__ import annotations\nimport json\nimport copy\nfrom typing import Any, Dict, Optional\n\n\n# ---- Default genome (same structure/values I proposed) ----\nDEFAULT_GENOME: Dict[str, Any] = {\n    \"forbidden\": {\n        \"w_stats\": 1.0,\n        \"w_match\": 0.0,\n        \"w_random\": 0.0,\n        \"w_anti\": 0.0,\n        \"prefer_info_if_tied\": 0.5,\n        \"gate_last_seat_boost_stats\": 0.5,\n        \"gate_trailing_boost_stats\": 0.5,\n        \"trail_threshold\": 3.0\n    },\n    \"draw_policy\": {\n        \"min_target_plus\": 3,\n        \"min_target_times\": 3,\n        \"min_target_last_seat\": 0,\n        \"min_target_r5_bump\": 0,\n        \"plus_scale_base\": 0.95,\n        \"times_scale_base\": 0.85,\n        \"w_scale_lead\": 0.04,\n        \"w_scale_trail\": -0.04,\n        \"w_scale_is_last\": -0.03,\n        \"w_scale_round_weight\": 0.01,\n        \"w_scale_suit_skew\": 0.03,\n        \"jitter\": 0.02,\n        \"push_times_to3_if_p_bust_below\": 0.33,\n        \"push_times_to4_if_p_bust_below\": 0.15,\n        \"push_plus_to4_if_p_bust_below\": 0.14,\n        \"brake_if_large_lead_r5\": 6.0,\n        \"brake_scale_r5\": 0.15,\n        \"bank5_bias_plus\": 0.25,\n        \"bank5_bias_times\": 0.15,\n        \"w_scale_overtake\": 0.05\n    },\n    \"ops_policy\": {\n        \"x_prob_s_le2\": 0.30,\n        \"x_prob_s_3_4\": 0.45,\n        \"x_prob_s_ge5\": 0.62,\n        \"w_xprob_trail\": 0.10,\n        \"w_xprob_lead\": -0.08,\n        \"w_xprob_is_last\": 0.05,\n        \"w_xprob_round\": -0.02,\n        \"x_repeat_s_le3\": 0.10,\n        \"x_repeat_s_4_5\": 0.18,\n        \"x_repeat_s_ge6\": 0.30,\n        \"w_xrep_trail\": 0.08,\n        \"w_xrep_lead\": -0.06,\n        \"w_xrep_round\": -0.02,\n        \"w_xprob_overtake\": 0.08,\n        \"w_xrep_overtake\": 0.05\n    },\n    \"overtake_proxy\": {\n        \"w_trail\": 0.5,\n        \"w_rounds_left\": 0.3,\n        \"w_is_last\": 0.2\n    },\n    \"fitness_penalty\": {\n        \"seat_variance_weight\": 0.05\n    }\n}\n\n\ndef _deep_merge(dst: Dict[str, Any], src: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"dst <- merge(src) without mutating src; src keys override dst.\"\"\"\n    out = copy.deepcopy(dst)\n    for k, v in src.items():\n        if isinstance(v, dict) and isinstance(out.get(k), dict):\n            out[k] = _deep_merge(out[k], v)  # type: ignore\n        else:\n            out[k] = v\n    return out\n\n\ndef load_genome(path: Optional[str]) -> Dict[str, Any]:\n    \"\"\"\n    Load a genome JSON file and fill any missing fields with DEFAULT_GENOME.\n    If path is None, return a deep copy of DEFAULT_GENOME.\n    \"\"\"\n    if not path:\n        return copy.deepcopy(DEFAULT_GENOME)\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        user = json.load(f)\n    return _deep_merge(DEFAULT_GENOME, user)\n\n\ndef save_genome(path: str, genome: Dict[str, Any]) -> None:\n    \"\"\"Save genome to JSON (pretty).\"\"\"\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(genome, f, indent=2, ensure_ascii=False)\n"
    },
    {
      "path": "evo_player.py",
      "content": "# evo_player.py\nfrom __future__ import annotations\nimport math\nimport random\nfrom typing import Any, Dict, List, Optional\n\nfrom players import BasePlayer\nfrom cards import SUITS, Card\nfrom utils import evaluate_expression\nfrom evo_io import load_genome\n\n\n# ---------- small math helpers ----------\ndef clamp(x: float, lo: float, hi: float) -> float:\n    return lo if x < lo else hi if x > hi else x\n\ndef sigmoid(z: float) -> float:\n    return 1.0 / (1.0 + math.exp(-z))\n\ndef logit(p: float, eps: float = 1e-9) -> float:\n    p = clamp(p, eps, 1 - eps)\n    return math.log(p / (1 - p))\n\ndef softmax(logits: List[float]) -> List[float]:\n    m = max(logits)\n    exps = [math.exp(z - m) for z in logits]\n    s = sum(exps)\n    return [e / s for e in exps] if s > 0 else [1.0 / len(logits)] * len(logits)\n\n\n# ---------- EvoPlayer ----------\nclass EvoPlayer(BasePlayer):\n    \"\"\"\n    Context-aware, genome-driven bot.\n    Reads a JSON genome (see evo_io.DEFAULT_GENOME) and makes decisions using:\n      • table state (scores so far, ops so far)\n      • round index and seat (first/last)\n      • deck odds (p_bust)\n    \"\"\"\n\n    def __init__(self, name: str, genome_path: Optional[str] = None, genome: Optional[Dict[str, Any]] = None):\n        super().__init__(name)\n        self.g = genome if genome is not None else load_genome(genome_path)\n        self._forbidden: Optional[str] = None\n\n    # ====== Helpers to read public context ======\n    def _seat_info(self, ctx: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Derive seat position & flags from ctx['public']['turn_order'].\"\"\"\n        pub = ctx.get(\"public\") or {}\n        order: List[str] = pub.get(\"turn_order\") or []\n        try:\n            seat_idx = order.index(self.name)  # 0-based\n        except ValueError:\n            seat_idx = 0\n        n = len(order) if order else 1\n        return {\n            \"seat_idx\": seat_idx,\n            \"num_players\": n,\n            \"is_first\": seat_idx == 0,\n            \"is_last\": seat_idx == (n - 1),\n            \"seat_pos\": seat_idx + 1\n        }\n\n    def _table_totals(self, ctx: Dict[str, Any]) -> Dict[str, int]:\n        \"\"\"Evaluate partial totals for everyone based on scores/ops so far (finished rounds only).\"\"\"\n        pub = ctx.get(\"public\") or {}\n        entries = pub.get(\"players_public\") or []\n        totals: Dict[str, int] = {}\n        for e in entries:\n            nm = e.get(\"name\")\n            sc = e.get(\"scores\") or []\n            ops = e.get(\"ops\") or []\n            try:\n                totals[nm] = evaluate_expression(sc, ops)\n            except Exception:\n                totals[nm] = sum(sc) if sc else 0\n        return totals\n\n    def _lead_margins(self, ctx: Dict[str, Any]) -> Dict[str, float]:\n        \"\"\"My lead/trail vs table.\"\"\"\n        totals = self._table_totals(ctx)\n        my = totals.get(self.name, 0)\n        others = [v for k, v in totals.items() if k != self.name]\n        max_others = max(others) if others else 0\n        med_others = sorted(others)[len(others)//2] if others else 0\n        return {\n            \"my_total\": my,\n            \"max_others\": max_others,\n            \"median_others\": med_others,\n            \"lead_margin\": my - max_others,       # >0 if I'm leading\n            \"median_margin\": my - med_others\n        }\n\n    def _overtake_risk(self, rounds_left: int, lead_margin: float, is_last: bool) -> float:\n        \"\"\"Simple proxy in [0,1]; parameters from genome.overtake_proxy.\"\"\"\n        w = self.g[\"overtake_proxy\"]\n        # normalize: lead/deficit per 10 pts; rounds_left scaled by /5\n        trail_norm = clamp(-lead_margin / 10.0, 0.0, 1.0)\n        rl_norm = clamp(rounds_left / 5.0, 0.0, 1.0)\n        x = w[\"w_trail\"] * trail_norm + w[\"w_rounds_left\"] * rl_norm + w[\"w_is_last\"] * (1.0 if is_last else 0.0)\n        return clamp(sigmoid(3 * (x - 0.5)), 0.0, 1.0)  # sharpen a little\n\n    def _suit_concentration(self, rem_by: Dict[str, int]) -> float:\n        \"\"\"How skewed suits are; 1.0 ≈ very skewed, 0 ≈ uniform-ish.\"\"\"\n        if not rem_by:\n            return 0.0\n        total = sum(rem_by.values())\n        if total <= 0:\n            return 0.0\n        ideal = total / 4.0\n        mx = max(rem_by.values())\n        return clamp((mx - ideal) / max(1.0, ideal), 0.0, 1.0)\n\n    # ====== Forbidden suit ======\n    def choose_forbidden_suit(self, first_revealed: Card, ctx: Dict[str, Any]) -> str:\n        f = self.g[\"forbidden\"]\n        seat = self._seat_info(ctx)\n        r_idx = ctx.get(\"round_index\", 1)\n        rounds_left = max(0, 5 - int(r_idx))\n\n        # base logits\n        L_stats = f[\"w_stats\"]\n        L_match = f[\"w_match\"]\n        L_random = f[\"w_random\"]\n        L_anti = f[\"w_anti\"]\n\n        # gates\n        margins = self._lead_margins(ctx)\n        if seat[\"is_last\"] and rounds_left <= 2:\n            L_stats += f[\"gate_last_seat_boost_stats\"]\n        if margins[\"lead_margin\"] < -float(f[\"trail_threshold\"]):\n            L_stats += f[\"gate_trailing_boost_stats\"]\n\n        logits = [L_stats, L_match, L_random, L_anti]\n        probs = softmax(logits)  # order: stats, match, random, anti\n\n        # Stats you need\n        rem_by: Dict[str, int] = ctx.get(\"deck_remaining_by_suit\") or {}\n        # pick a mode\n        u = random.random()\n        mode = 0 if u < probs[0] else 1 if u < probs[0] + probs[1] else 2 if u < probs[0] + probs[1] + probs[2] else 3\n\n        # Mode behaviors\n        if mode == 0 and rem_by and all(s in rem_by for s in SUITS):\n            # stats: choose among suit(s) with FEWEST remaining (MOST revealed)\n            min_left = min(rem_by[s] for s in SUITS)\n            fewest = [s for s in SUITS if rem_by[s] == min_left]\n            if first_revealed.suit in fewest and random.random() < f[\"prefer_info_if_tied\"]:\n                choice = first_revealed.suit\n            else:\n                choice = random.choice(fewest)\n        elif mode == 1:\n            choice = first_revealed.suit\n        elif mode == 2:\n            choice = random.choice(SUITS)\n        else:\n            # anti-info: avoid the info suit if possible\n            alts = [s for s in SUITS if s != first_revealed.suit] or list(SUITS)\n            choice = random.choice(alts)\n\n        self._forbidden = choice\n        return choice\n\n    # ====== Continue or stop ======\n    def choose_continue_or_stop(self, current_points: int, ctx: Dict[str, Any]) -> str:\n        dp = self.g[\"draw_policy\"]\n        seat = self._seat_info(ctx)\n        r_idx = int(ctx.get(\"round_index\", 1))\n        rounds_left = max(0, 5 - r_idx)\n        last_op = self.ops_between[-1] if self.ops_between else \"+\"\n        rem_by: Dict[str, int] = ctx.get(\"deck_remaining_by_suit\") or {}\n        forb = self._forbidden\n\n        # p_bust\n        remaining = sum(rem_by.values()) if rem_by else 0\n        forbidden_left = rem_by.get(forb, 0) if (rem_by and forb in rem_by) else 0\n        p_bust = (forbidden_left / remaining) if remaining > 0 else 1.0\n\n        # features\n        margins = self._lead_margins(ctx)\n        lead = float(margins[\"lead_margin\"])\n        is_last = bool(seat[\"is_last\"])\n        suit_skew = self._suit_concentration(rem_by)\n        risk_overtake = self._overtake_risk(rounds_left, lead, is_last)\n\n        # min target adjustments\n        min_target = dp[\"min_target_times\"] if last_op == \"x\" else dp[\"min_target_plus\"]\n        min_target += dp[\"min_target_last_seat\"] if is_last else 0\n        if r_idx == 5:\n            min_target += dp[\"min_target_r5_bump\"]\n        if current_points < min_target:\n            return \"continue\"\n\n        # EV-ish threshold with context\n        base = dp[\"times_scale_base\"] if last_op == \"x\" else dp[\"plus_scale_base\"]\n        scale = base\n        # Lead/trail normalization: per 10 pts swing\n        if lead >= 0:\n            scale += dp[\"w_scale_lead\"] * (lead / 10.0)\n        else:\n            scale += dp[\"w_scale_trail\"] * (-lead / 10.0)\n        scale += dp[\"w_scale_is_last\"] * (1.0 if is_last else 0.0)\n        scale += dp[\"w_scale_round_weight\"] * (r_idx - 3.0)\n        scale += dp[\"w_scale_suit_skew\"] * suit_skew\n        scale += dp[\"w_scale_overtake\"] * risk_overtake\n\n        thresh = scale / (current_points + 1.0)\n\n        # Push/Brake rules\n        if last_op == \"x\":\n            if current_points < 3 and p_bust <= dp[\"push_times_to3_if_p_bust_below\"]:\n                return \"continue\"\n            if current_points < 4 and p_bust <= dp[\"push_times_to4_if_p_bust_below\"]:\n                return \"continue\"\n        else:\n            if current_points < 4 and p_bust <= dp[\"push_plus_to4_if_p_bust_below\"]:\n                return \"continue\"\n\n        if r_idx == 5 and lead >= dp[\"brake_if_large_lead_r5\"]:\n            thresh += dp[\"brake_scale_r5\"]\n\n        # Jitter to avoid determinism\n        jitter = random.uniform(-dp[\"jitter\"], dp[\"jitter\"])\n        # Bank@5 bias when marginal\n        if current_points == 5:\n            bias = dp[\"bank5_bias_times\"] if last_op == \"x\" else dp[\"bank5_bias_plus\"]\n            # If we are just above/below the line, flip biased coin to bank\n            margin = p_bust - (thresh + jitter)\n            if -0.02 <= margin <= 0.02:  # marginal zone\n                return \"stop\" if random.random() < bias else \"continue\"\n\n        return \"stop\" if p_bust >= (thresh + jitter) else \"continue\"\n\n    # ====== Operator between rounds ======\n    def choose_operator_between_rounds(\n        self,\n        my_scores: List[int],\n        all_scores: Dict[str, List[int]],\n        previous_picks: List[Dict[str, str]],\n        ctx: Dict[str, Any],\n    ) -> str:\n        opg = self.g[\"ops_policy\"]\n        seat = self._seat_info(ctx)\n        r_idx = int(ctx.get(\"round_index\", 1))\n        rounds_left = max(0, 5 - r_idx)\n        margins = self._lead_margins(ctx)\n        lead = float(margins[\"lead_margin\"])\n        is_last = bool(seat[\"is_last\"])\n        last_score = my_scores[-1] if my_scores else 0\n\n        # Never multiply from zero\n        if last_score == 0:\n            return \"+\"\n\n        # Repeat × or start new?\n        prev_op = self.ops_between[-1] if self.ops_between else None\n\n        # Build a base probability based on last round score\n        def base_prob_for_score(s: int, a: float, b: float, c: float) -> float:\n            if s >= 5:\n                return c\n            elif s >= 3:\n                return b\n            else:\n                return a\n\n        # context scalers (logit space recommended; here we clamp)\n        lead_norm = clamp(lead / 10.0, -1.0, 1.0)\n        round_shift = (r_idx - 3.0) / 2.0  # -1 @R1 .. +1 @R5\n        overtake = self._overtake_risk(rounds_left, lead, is_last)\n\n        if prev_op == \"x\":\n            p = base_prob_for_score(\n                last_score,\n                opg[\"x_repeat_s_le3\"],\n                opg[\"x_repeat_s_4_5\"],\n                opg[\"x_repeat_s_ge6\"],\n            )\n            z = logit(p)\n            z += opg[\"w_xrep_trail\"] * clamp(-lead_norm, 0.0, 1.0)    # trailing → higher\n            z += opg[\"w_xrep_lead\"] * clamp(+lead_norm, 0.0, 1.0)     # leading → lower\n            z += opg[\"w_xrep_round\"] * round_shift\n            z += opg[\"w_xrep_overtake\"] * overtake\n            p_final = clamp(sigmoid(z), 0.0, 1.0)\n            return \"x\" if random.random() < p_final else \"+\"\n\n        else:\n            p = base_prob_for_score(\n                last_score,\n                opg[\"x_prob_s_le2\"],\n                opg[\"x_prob_s_3_4\"],\n                opg[\"x_prob_s_ge5\"],\n            )\n            z = logit(p)\n            z += opg[\"w_xprob_trail\"] * clamp(-lead_norm, 0.0, 1.0)\n            z += opg[\"w_xprob_lead\"] * clamp(+lead_norm, 0.0, 1.0)\n            z += opg[\"w_xprob_is_last\"] * (1.0 if is_last else 0.0)\n            z += opg[\"w_xprob_round\"] * round_shift\n            z += opg[\"w_xprob_overtake\"] * overtake\n            p_final = clamp(sigmoid(z), 0.0, 1.0)\n            return \"x\" if random.random() < p_final else \"+\"\n"
    },
    {
      "path": "evo_pods_runner.py",
      "content": "#!/usr/bin/env python3\n# evo_pods_runner.py\nfrom __future__ import annotations\nimport json\n\nfrom ga.ga_types import GARunConfig, MutateParams, CrossoverParams\nfrom ga.ga_runner import GARunner, RunnerDeps\nfrom ga.ga_controls import ControlPool\nfrom ga.ga_mutation import Mutator\nfrom ga.ga_crossover import CrossoverOperator\nfrom ga.pod_population_evaluator import PodPopulationEvaluator\n\n# ANSI colors for a nice header (optional)\nCOLORS = {\n    \"HEADER\": \"\\033[95m\", \"BLUE\": \"\\033[94m\", \"CYAN\": \"\\033[96m\",\n    \"GREEN\": \"\\033[92m\", \"YELLOW\": \"\\033[93m\", \"RED\": \"\\033[91m\",\n    \"BOLD\": \"\\033[1m\", \"UNDERLINE\": \"\\033[4m\", \"END\": \"\\033[0m\",\n}\ndef cprint(text: str, color: str = \"GREEN\", bold: bool = False) -> None:\n    style = COLORS[\"BOLD\"] if bold else \"\"\n    print(f\"{style}{COLORS[color]}{text}{COLORS['END']}\")\n\nif __name__ == \"__main__\":\n    # Tune these like you did for evo_runner; here games_per_eval == pod \"rounds\"\n    cfg = GARunConfig(\n        pop_size=35,\n        generations=50,\n        games_per_eval=120,   # <- rounds per generation in pod scheduling\n        elitism=10,\n        tourney_size=8,\n        mutate_params=MutateParams(sigma_frac=0.12, per_gene_prob=0.35, reset_prob=0.06),\n        crossover_params=CrossoverParams(alpha_min=0.3, alpha_max=0.7, per_gene_prob=0.9),\n        eval_seed=42,\n        log_every=1,\n    )\n\n    cprint(\"\\n=== GA with Pod-Based Evaluation ===\", \"HEADER\", bold=True)\n    print(\n        f\"Population: {cfg.pop_size} | Generations: {cfg.generations} | \"\n        f\"Rounds/Gen: {cfg.games_per_eval} | Elitism: {cfg.elitism} | \"\n        f\"Tournament: {cfg.tourney_size}\"\n    )\n\n    evaluator = PodPopulationEvaluator(pod_size=5, k_factor=24.0)\n    mutator = Mutator(cfg.mutate_params)\n    crosser = CrossoverOperator(cfg.crossover_params)\n    controls = ControlPool()  # not used by pod evaluator, but fine for runner summary\n\n    deps = RunnerDeps(\n        evaluator=evaluator,\n        mutator=mutator,\n        crosser=crosser,\n        controls=controls,\n    )\n\n    runner = GARunner(cfg, deps)\n    best_g, best_f = runner.evolve()\n\n    cprint(\"\\n=== Best Genome (pods GA) ===\", \"HEADER\", bold=True)\n    payload = best_g.to_json() if hasattr(best_g, \"to_json\") else getattr(best_g, \"data\", {})\n    print(json.dumps(payload, indent=2))\n\n    cprint(\"\\n=== Best Fitness ===\", \"HEADER\", bold=True)\n    bust_rate = float(best_f.diagnostics.get(\"bust_rate\", 0.0)) if getattr(best_f, \"diagnostics\", None) else 0.0\n    print(\n        f\"Median {best_f.median:.2f} | Win% {100*best_f.win_rate:.2f}% | \"\n        f\"Q1 {best_f.q1:.2f} | Q3 {best_f.q3:.2f} | \"\n        f\"Max {best_f.max_score} | Min {best_f.min_score} | \"\n        f\"Bust% {100*bust_rate:.2f}%\"\n    )\n"
    },
    {
      "path": "evo_runner.py",
      "content": "#!/usr/bin/env python3\n# evo_runner.py\n\nfrom __future__ import annotations\nimport json\n\n# Old-style config types you already have\nfrom ga.ga_types import GARunConfig, MutateParams, CrossoverParams\n\n# New runner + deps\nfrom ga.ga_runner import GARunner, RunnerDeps\nfrom ga.ga_controls import ControlPool\nfrom ga.ga_evaluator import PopulationEvaluator\nfrom ga.ga_mutation import Mutator\nfrom ga.ga_crossover import CrossoverOperator\n\n# ANSI colors\nCOLORS = {\n    \"HEADER\": \"\\033[95m\",\n    \"BLUE\": \"\\033[94m\",\n    \"CYAN\": \"\\033[96m\",\n    \"GREEN\": \"\\033[92m\",\n    \"YELLOW\": \"\\033[93m\",\n    \"RED\": \"\\033[91m\",\n    \"BOLD\": \"\\033[1m\",\n    \"UNDERLINE\": \"\\033[4m\",\n    \"END\": \"\\033[0m\",\n}\n\ndef color_print(text: str, color: str = \"GREEN\", bold: bool = False) -> None:\n    style = COLORS[\"BOLD\"] if bold else \"\"\n    print(f\"{style}{COLORS[color]}{text}{COLORS['END']}\")\n\n# ---------- Compat shim so GARunner sees the fields it expects ----------\nclass CompatCfg:\n    def __init__(self, old: GARunConfig, verbose_game: int = 0):\n        self.population_size = getattr(old, \"pop_size\")\n        self.generations = getattr(old, \"generations\")\n        self.games_per_eval = getattr(old, \"games_per_eval\")\n        self.elitism = getattr(old, \"elitism\")\n        self.tournament_size = getattr(old, \"tourney_size\")\n        self.seed = getattr(old, \"eval_seed\", None)\n        self.verbose_game = verbose_game\n\n        # If your GARunner ever reads these, they’re here; otherwise harmless.\n        mp = getattr(old, \"mutate_params\", None)\n        cp = getattr(old, \"crossover_params\", None)\n        self.mutation_sigma_frac = getattr(mp, \"sigma_frac\", 0.1) if mp else 0.1\n        self.mutation_prob = getattr(mp, \"per_gene_prob\", 0.2) if mp else 0.2\n        self.reset_prob = getattr(mp, \"reset_prob\", 0.0) if mp else 0.0\n        self.crossover_alpha_min = getattr(cp, \"alpha_min\", 0.3) if cp else 0.3\n        self.crossover_alpha_max = getattr(cp, \"alpha_max\", 0.7) if cp else 0.7\n        self.crossover_prob = getattr(cp, \"per_gene_prob\", 0.9) if cp else 0.9\n\n# ---------- Robust builders that try multiple APIs ----------\ndef build_mutator(mp: MutateParams) -> Mutator:\n    # 1) Known factory names\n    for fname in (\"from_params\", \"from_config\", \"make\", \"create\", \"build\"):\n        if hasattr(Mutator, fname):\n            try:\n                return getattr(Mutator, fname)(mp)\n            except TypeError:\n                pass\n\n    # 2) Try passing the config object directly\n    try:\n        return Mutator(mp)\n    except TypeError:\n        pass\n\n    # 3) Keyword variants\n    kw_variants = [\n        dict(sigma_frac=getattr(mp, \"sigma_frac\", None),\n             per_gene_prob=getattr(mp, \"per_gene_prob\", None),\n             reset_prob=getattr(mp, \"reset_prob\", None)),\n        dict(sigma=getattr(mp, \"sigma_frac\", None),\n             per_gene=getattr(mp, \"per_gene_prob\", None),\n             reset=getattr(mp, \"reset_prob\", None)),\n        dict(sigma_fraction=getattr(mp, \"sigma_frac\", None),\n             per_gene_probability=getattr(mp, \"per_gene_prob\", None),\n             reset_probability=getattr(mp, \"reset_prob\", None)),\n    ]\n    for kwargs in kw_variants:\n        # remove Nones so we don't pass unknown names unnecessarily\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        try:\n            if kwargs:\n                return Mutator(**kwargs)\n        except TypeError:\n            continue\n\n    # 4) Positional fallbacks\n    pos = (getattr(mp, \"sigma_frac\", 0.1),\n           getattr(mp, \"per_gene_prob\", 0.2),\n           getattr(mp, \"reset_prob\", 0.0))\n    for args in (pos, pos[:2], tuple()):\n        try:\n            return Mutator(*args)\n        except TypeError:\n            continue\n\n    # 5) Absolute fallback: default-construct, then setattr if attributes exist\n    m = Mutator()\n    for k in (\"sigma_frac\", \"per_gene_prob\", \"reset_prob\"):\n        if hasattr(m, k) and hasattr(mp, k):\n            setattr(m, k, getattr(mp, k))\n    return m\n\ndef build_crosser(cp: CrossoverParams) -> CrossoverOperator:\n    # 1) Factories\n    for fname in (\"from_params\", \"from_config\", \"make\", \"create\", \"build\"):\n        if hasattr(CrossoverOperator, fname):\n            try:\n                return getattr(CrossoverOperator, fname)(cp)\n            except TypeError:\n                pass\n\n    # 2) Try passing config directly\n    try:\n        return CrossoverOperator(cp)\n    except TypeError:\n        pass\n\n    # 3) Keyword variants\n    kw_variants = [\n        dict(alpha_min=getattr(cp, \"alpha_min\", None),\n             alpha_max=getattr(cp, \"alpha_max\", None),\n             per_gene_prob=getattr(cp, \"per_gene_prob\", None)),\n        dict(alpha_lo=getattr(cp, \"alpha_min\", None),\n             alpha_hi=getattr(cp, \"alpha_max\", None),\n             per_gene=getattr(cp, \"per_gene_prob\", None)),\n    ]\n    for kwargs in kw_variants:\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        try:\n            if kwargs:\n                return CrossoverOperator(**kwargs)\n        except TypeError:\n            continue\n\n    # 4) Positional fallbacks\n    pos = (getattr(cp, \"alpha_min\", 0.3),\n           getattr(cp, \"alpha_max\", 0.7),\n           getattr(cp, \"per_gene_prob\", 0.9))\n    for args in (pos, pos[:2], tuple()):\n        try:\n            return CrossoverOperator(*args)\n        except TypeError:\n            continue\n\n    return CrossoverOperator()\n\n# ---------- Main ----------\nif __name__ == \"__main__\":\n    color_print(\"\\n=== Genetic Algorithm Configuration ===\", \"HEADER\", bold=True)\n\n    base_cfg = GARunConfig(\n        pop_size=35,\n        generations=200,\n        games_per_eval=1500,\n        elitism=10,\n        tourney_size=8,\n        mutation_after_crossover=True,\n        mutate_params=MutateParams(sigma_frac=0.12, per_gene_prob=0.35, reset_prob=0.06),\n        crossover_params=CrossoverParams(alpha_min=0.3, alpha_max=0.7, per_gene_prob=0.9),\n        eval_seed=42,\n        log_every=1,\n    )\n\n    print(\n        f\"\"\"\n    Population Size: {COLORS['CYAN']}{base_cfg.pop_size}{COLORS['END']}\n    Generations: {COLORS['CYAN']}{base_cfg.generations}{COLORS['END']}\n    Games per Evaluation: {COLORS['YELLOW']}{base_cfg.games_per_eval}{COLORS['END']}\n    Elitism: {COLORS['GREEN']}{base_cfg.elitism}{COLORS['END']}\n    Tournament Size: {COLORS['GREEN']}{base_cfg.tourney_size}{COLORS['END']}\n    Mutation:\n      Sigma Fraction: {COLORS['RED']}{base_cfg.mutate_params.sigma_frac}{COLORS['END']}\n      Per-Gene Probability: {COLORS['RED']}{base_cfg.mutate_params.per_gene_prob}{COLORS['END']}\n      Reset Probability: {COLORS['RED']}{base_cfg.mutate_params.reset_prob}{COLORS['END']}\n    Crossover:\n      Alpha Range: {COLORS['BLUE']}[{base_cfg.crossover_params.alpha_min}, {base_cfg.crossover_params.alpha_max}]{COLORS['END']}\n      Per-Gene Probability: {COLORS['BLUE']}{base_cfg.crossover_params.per_gene_prob}{COLORS['END']}\n        \"\"\".rstrip()\n    )\n\n    # Build deps (keep only MetaOne if your ControlPool supports it)\n    controls = ControlPool()  # or ControlPool(only=[\"MetaOne\"])\n    evaluator = PopulationEvaluator(controls)\n    mutator = build_mutator(base_cfg.mutate_params)\n    crosser = build_crosser(base_cfg.crossover_params)\n\n    deps = RunnerDeps(\n        evaluator=evaluator,\n        mutator=mutator,\n        crosser=crosser,\n        controls=controls,\n    )\n\n    # Shim config so GARunner sees expected attribute names\n    cfg = CompatCfg(base_cfg, verbose_game=0)\n\n    color_print(\"=== Starting Evolution ===\", \"HEADER\", bold=True)\n    runner = GARunner(cfg, deps)\n    best_g, best_f = runner.evolve()\n\n    color_print(\"\\n=== Best Genome ===\", \"HEADER\", bold=True)\n    payload = best_g.to_json() if hasattr(best_g, \"to_json\") else getattr(best_g, \"data\", {})\n    print(json.dumps(payload, indent=2))\n\n    color_print(\"\\n=== Best Fitness ===\", \"HEADER\", bold=True)\n    bust_rate = 0.0\n    if hasattr(best_f, \"diagnostics\") and isinstance(best_f.diagnostics, dict):\n        bust_rate = float(best_f.diagnostics.get(\"bust_rate\", 0.0))\n    print(\n        f\"{COLORS['BOLD']}Median Score:{COLORS['END']} {COLORS['GREEN']}{getattr(best_f, 'median', 0.0):.2f}{COLORS['END']}\\n\"\n        f\"{COLORS['BOLD']}Win Rate:{COLORS['END']} {COLORS['CYAN']}{100*getattr(best_f, 'win_rate', 0.0):.2f}%{COLORS['END']}\\n\"\n        f\"{COLORS['BOLD']}Max Score:{COLORS['END']} {COLORS['YELLOW']}{getattr(best_f, 'max_score', 0)}{COLORS['END']}\\n\"\n        f\"{COLORS['BOLD']}Min Score:{COLORS['END']} {COLORS['RED']}{getattr(best_f, 'min_score', 0)}{COLORS['END']}\\n\"\n        f\"{COLORS['BOLD']}Bust Rate:{COLORS['END']} {COLORS['RED']}{100*bust_rate:.2f}%{COLORS['END']}\"\n    )\n"
    },
    {
      "path": "ga/__intit__.py",
      "content": ""
    },
    {
      "path": "ga/ga_bounds.py",
      "content": "# ga_bounds.py\nfrom typing import Any, Dict, List, Tuple\n\nFLOAT_BOUNDS: Dict[str, Tuple[float, float]] = {\n    \"forbidden.w_stats\": (-3.0, 3.0),\n    \"forbidden.w_match\": (-3.0, 3.0),\n    \"forbidden.w_random\": (-3.0, 3.0),\n    \"forbidden.w_anti\": (-3.0, 3.0),\n    \"forbidden.prefer_info_if_tied\": (0.0, 1.0),\n    \"forbidden.gate_last_seat_boost_stats\": (-1.0, 1.5),\n    \"forbidden.gate_trailing_boost_stats\": (-1.0, 1.5),\n    \"forbidden.trail_threshold\": (0.0, 12.0),\n\n    \"draw_policy.plus_scale_base\": (0.5, 1.4),\n    \"draw_policy.times_scale_base\": (0.4, 1.4),\n    \"draw_policy.w_scale_lead\": (-0.2, 0.2),\n    \"draw_policy.w_scale_trail\": (-0.2, 0.2),\n    \"draw_policy.w_scale_is_last\": (-0.2, 0.2),\n    \"draw_policy.w_scale_round_weight\": (-0.1, 0.1),\n    \"draw_policy.w_scale_suit_skew\": (-0.2, 0.2),\n    \"draw_policy.w_scale_overtake\": (-0.2, 0.2),\n    \"draw_policy.jitter\": (0.0, 0.06),\n    \"draw_policy.push_times_to3_if_p_bust_below\": (0.05, 0.50),\n    \"draw_policy.push_times_to4_if_p_bust_below\": (0.05, 0.40),\n    \"draw_policy.push_plus_to4_if_p_bust_below\": (0.05, 0.40),\n    \"draw_policy.brake_if_large_lead_r5\": (0.0, 20.0),\n    \"draw_policy.brake_scale_r5\": (0.0, 0.5),\n    \"draw_policy.bank5_bias_plus\": (0.0, 0.9),\n    \"draw_policy.bank5_bias_times\": (0.0, 0.9),\n\n    \"ops_policy.x_prob_s_le2\": (0.0, 0.9),\n    \"ops_policy.x_prob_s_3_4\": (0.0, 0.9),\n    \"ops_policy.x_prob_s_ge5\": (0.0, 0.95),\n    \"ops_policy.w_xprob_trail\": (-0.3, 0.3),\n    \"ops_policy.w_xprob_lead\": (-0.3, 0.3),\n    \"ops_policy.w_xprob_is_last\": (-0.3, 0.3),\n    \"ops_policy.w_xprob_round\": (-0.3, 0.3),\n    \"ops_policy.x_repeat_s_le3\": (0.0, 0.9),\n    \"ops_policy.x_repeat_s_4_5\": (0.0, 0.9),\n    \"ops_policy.x_repeat_s_ge6\": (0.0, 0.95),\n    \"ops_policy.w_xrep_trail\": (-0.3, 0.3),\n    \"ops_policy.w_xrep_lead\": (-0.3, 0.3),\n    \"ops_policy.w_xrep_round\": (-0.3, 0.3),\n    \"ops_policy.w_xprob_overtake\": (-0.3, 0.3),\n    \"ops_policy.w_xrep_overtake\": (-0.3, 0.3),\n\n    \"overtake_proxy.w_trail\": (0.0, 1.5),\n    \"overtake_proxy.w_rounds_left\": (0.0, 1.5),\n    \"overtake_proxy.w_is_last\": (0.0, 1.5),\n\n    \"fitness_penalty.seat_variance_weight\": (0.0, 0.5),\n}\n\nINT_KEYS: Dict[str, Tuple[int, int]] = {\n    \"draw_policy.min_target_plus\": (2, 6),\n    \"draw_policy.min_target_times\": (2, 6),\n    \"draw_policy.min_target_last_seat\": (-1, 2),\n    \"draw_policy.min_target_r5_bump\": (-1, 2),\n}\n\ndef iter_paths(d: Dict[str, Any], prefix: str = \"\") -> List[str]:\n    out: List[str] = []\n    for k, v in d.items():\n        p = f\"{prefix}.{k}\" if prefix else k\n        if isinstance(v, dict):\n            out += iter_paths(v, p)\n        else:\n            out.append(p)\n    return out\n\ndef get_holder(d: Dict[str, Any], path: str):\n    cur = d\n    for k in path.split(\".\")[:-1]:\n        cur = cur[k]\n    return cur, path.split(\".\")[-1]\n\ndef clamp_to_bounds(path: str, val):\n    if path in INT_KEYS:\n        lo, hi = INT_KEYS[path]\n        return int(max(lo, min(hi, round(val))))\n    if path in FLOAT_BOUNDS:\n        lo, hi = FLOAT_BOUNDS[path]\n        return max(lo, min(hi, float(val)))\n    return val\n\ndef range_for(path: str) -> Tuple[float, float]:\n    if path in INT_KEYS:\n        lo, hi = INT_KEYS[path]\n        return float(lo), float(hi)\n    if path in FLOAT_BOUNDS:\n        return FLOAT_BOUNDS[path]\n    return -1.0, 1.0\n"
    },
    {
      "path": "ga/ga_controls.py",
      "content": "# ga_controls.py\nfrom __future__ import annotations\nfrom typing import List, Any, Optional\nimport os, json, copy\n\n# keep these imports if you still use them elsewhere\nfrom random_player import RandomPlayer   # noqa: F401\nfrom smart_player import SmartPlayer     # noqa: F401\nfrom hand_player import HandPlayer       # noqa: F401\n\nfrom meta_player import MetaPlayer\nfrom evo_player import EvoPlayer\n\n\nclass ControlPool:\n    def __init__(\n        self,\n        evo_path: str = \"good_bots/con1.json\",\n        include_meta: bool = True,\n        only: Optional[List[str]] = None,\n    ):\n        \"\"\"\n        include_meta: include MetaOne in controls\n        only: optional allowlist of control names to return, e.g. [\"EvoCtrl1\"] or [\"MetaOne\",\"EvoCtrl1\"]\n        evo_path: path to JSON file containing either:\n                  - {\"genome\": {...}}  (saved by repo)\n                  - {...}              (raw genome)\n        \"\"\"\n        self.evo_path = evo_path\n        self.include_meta = include_meta\n        self.only = set(only) if only else None\n        self._evo_genome = None  # cached after first successful load\n\n    def _load_evo_genome(self):\n        if self._evo_genome is not None:\n            return self._evo_genome\n\n        path = self.evo_path\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n            if isinstance(data, dict) and isinstance(data.get(\"genome\"), dict):\n                genome = data[\"genome\"]\n            elif isinstance(data, dict):\n                genome = data\n            else:\n                print(f\"[ga_controls] WARN: {path} did not contain a dict genome.\")\n                genome = None\n        except FileNotFoundError:\n            print(f\"[ga_controls] WARN: evo control file not found: {path}\")\n            genome = None\n        except Exception as e:\n            print(f\"[ga_controls] WARN: failed to load evo control from {path}: {e}\")\n            genome = None\n\n        self._evo_genome = genome\n        return genome\n\n    def make(self) -> List[Any]:\n        \"\"\"\n        Return the list of control players for a table.\n        Called frequently by evaluators, so we instantiate new player objects\n        but reuse the cached genome payload.\n        \"\"\"\n        bots: List[Any] = []\n\n        if self.include_meta and (self.only is None or \"MetaOne\" in self.only):\n            bots.append(MetaPlayer(\"MetaOne\"))\n\n        genome = self._load_evo_genome()\n        if genome is not None and (self.only is None or \"EvoCtrl1\" in self.only):\n            # pass a deep copy to avoid any accidental in-game mutation\n            bots.append(EvoPlayer(\"EvoCtrl1\", genome=copy.deepcopy(genome)))\n\n        return bots\n"
    },
    {
      "path": "ga/ga_crossover.py",
      "content": "# ga_crossover.py\nimport copy, random\nfrom .ga_types import CrossoverParams\nfrom .ga_bounds import iter_paths, get_holder, clamp_to_bounds, INT_KEYS\nfrom .ga_genome import Genome\n\n\nclass CrossoverOperator:\n    \"\"\"\n    Per-gene arithmetic (BLX-style) crossover with clamping.\n\n    Runner-compat change:\n      • crossover(self, a, b, rng=None, **kwargs) accepts an optional RNG supplied by the runner.\n        If not provided, falls back to a seed-based local RNG or global random.\n    \"\"\"\n    def __init__(self, params: CrossoverParams):\n        self.params = params\n\n    def crossover(self, a: Genome, b: Genome, rng: random.Random | None = None, **kwargs) -> Genome:\n        rnd = rng or (random.Random(self.params.seed) if self.params.seed is not None else random)\n        child = a.clone()\n        for path in iter_paths(child.data):\n            if rnd.random() > self.params.per_gene_prob:\n                continue\n\n            hold_c, kc = get_holder(child.data, path)\n            hold_a, ka = get_holder(a.data, path)\n            hold_b, kb = get_holder(b.data, path)\n            va, vb = hold_a[ka], hold_b[kb]\n\n            if isinstance(va, (int, float)) and isinstance(vb, (int, float)):\n                alpha = rnd.uniform(self.params.alpha_min, self.params.alpha_max)\n                v = alpha * va + (1 - alpha) * vb\n                if path in INT_KEYS:\n                    v = round(v)\n                hold_c[kc] = clamp_to_bounds(path, v)\n            else:\n                # Non-numeric genes: copy from parent A (could randomize parent choice if desired)\n                hold_c[kc] = copy.deepcopy(va)\n\n        return child\n"
    },
    {
      "path": "ga/ga_evaluator.py",
      "content": "# ga/ga_evaluator.py\nimport math\nimport random\nimport statistics as stats\nfrom typing import Any, Dict, List, Tuple\n\nfrom .ga_types import Fitness\nfrom .ga_genome import Genome\nfrom .ga_controls import ControlPool\nfrom evo_player import EvoPlayer\nfrom game import SuitsGambitGame\n\n\ndef _quartiles(values: List[int]) -> tuple[float, float]:\n    \"\"\"Return (Q1, Q3). Robust for small n; falls back to linear percentile.\"\"\"\n    if not values:\n        return 0.0, 0.0\n    try:\n        # Python 3.8+: inclusive matches spreadsheet-style quartiles well\n        qs = stats.quantiles(values, n=4, method=\"inclusive\")\n        # qs = [Q1, median, Q3]\n        return float(qs[0]), float(qs[2])\n    except Exception:\n        s = sorted(values)\n        n = len(s)\n        if n == 1:\n            return float(s[0]), float(s[0])\n\n        def pctl(p: float) -> float:\n            k = (n - 1) * p\n            f = math.floor(k)\n            c = math.ceil(k)\n            if f == c:\n                return float(s[f])\n            return float(s[f] + (s[c] - s[f]) * (k - f))\n\n        return pctl(0.25), pctl(0.75)\n\n\nclass PopulationEvaluator:\n    \"\"\"\n    Fitness = multi-criteria:\n      1) win_rate (primary),\n      2) median score (secondary),\n      3) Q1, then Q3 (tertiary).\n    All other diagnostics are for logging only.\n    \"\"\"\n    def __init__(self, controls: ControlPool):\n        self.controls = controls\n\n    def evaluate_all_in_one(\n        self,\n        pop: List[Genome],\n        games_per_eval: int = 1000,\n        base_seed: int = 123,\n        verbose_game: int = 0\n    ) -> Tuple[List[Fitness], Dict[str, Fitness]]:\n\n        P = len(pop)\n        ctrl_players = self.controls.make()\n        ctrl_names = [c.name for c in ctrl_players]\n\n        # --- Accumulators ---\n        wins = [0 for _ in range(P)]\n        ctrl_wins: Dict[str, int] = {n: 0 for n in ctrl_names}\n\n        totals: List[List[int]] = [[] for _ in range(P)]\n        max_score = [0 for _ in range(P)]\n        min_score = [None for _ in range(P)]\n        bust_rounds = [0 for _ in range(P)]\n        rounds_played = [0 for _ in range(P)]\n\n        ctrl_totals: Dict[str, List[int]] = {n: [] for n in ctrl_names}\n        ctrl_max: Dict[str, int] = {n: 0 for n in ctrl_names}\n        ctrl_min: Dict[str, int | None] = {n: None for n in ctrl_names}\n        ctrl_bust_rounds: Dict[str, int] = {n: 0 for n in ctrl_names}\n        ctrl_rounds_played: Dict[str, int] = {n: 0 for n in ctrl_names}\n\n        # --- Simulate ---\n        for gidx in range(games_per_eval):\n            # Fresh Evo players each game\n            evos = [EvoPlayer(f\"Evo{i}\", genome=pop[i].to_json()) for i in range(P)]\n            # Mix with controls and shuffle seating deterministically per gidx\n            players = evos + self.controls.make()\n            random.Random(base_seed + gidx).shuffle(players)\n\n            game = SuitsGambitGame(players, verbose=verbose_game, seed=(base_seed + gidx))\n            winner, results = game.play()\n\n            name_to_idx = {f\"Evo{i}\": i for i in range(P)}\n            for p in players:\n                score = results[p.name]\n\n                if p.name in name_to_idx:\n                    i = name_to_idx[p.name]\n                    totals[i].append(score)\n                    max_score[i] = max(max_score[i], score)\n                    mn = min_score[i]\n                    min_score[i] = score if mn is None else min(mn, score)\n                    rounds_played[i] += len(p.round_scores)\n                    bust_rounds[i] += sum(1 for s in p.round_scores if s == 0)\n                elif p.name in ctrl_totals:\n                    ctrl_totals[p.name].append(score)\n                    ctrl_max[p.name] = max(ctrl_max[p.name], score)\n                    cmn = ctrl_min[p.name]\n                    ctrl_min[p.name] = score if cmn is None else min(cmn, score)\n                    ctrl_rounds_played[p.name] += len(p.round_scores)\n                    ctrl_bust_rounds[p.name] += sum(1 for s in p.round_scores if s == 0)\n\n            # WIN RATE only counts outright wins; ties give no credit\n            if winner in name_to_idx:\n                wins[name_to_idx[winner]] += 1\n            elif winner in ctrl_wins:\n                ctrl_wins[winner] += 1\n\n        # --- Finalize genomes ---\n        fits: List[Fitness] = []\n        for i in range(P):\n            wr = wins[i] / max(1, games_per_eval)\n\n            # robust summary stats (used for secondary ranking & diagnostics)\n            n = len(totals[i])\n            med = float(stats.median(totals[i])) if n else 0.0\n            q1, q3 = _quartiles(totals[i]) if n else (0.0, 0.0)\n            mean = (sum(totals[i]) / n) if n else 0.0\n            sd = stats.pstdev(totals[i]) if n > 1 else 0.0\n            mx = int(max_score[i]) if n else 0\n            mn = int(min_score[i]) if (min_score[i] is not None) else 0\n            br = (bust_rounds[i] / rounds_played[i]) if rounds_played[i] else 0.0\n            iqr = q3 - q1\n\n            fits.append(Fitness(\n                win_rate=wr,\n                median=med,\n                q1=q1,\n                q3=q3,\n                max_score=mx,\n                min_score=mn,\n                diagnostics={\n                    \"mean\": mean,\n                    \"sd\": sd,\n                    \"iqr\": iqr,\n                    \"bust_rate\": br,\n                    \"n_games\": n,\n                }\n            ))\n\n        # --- Finalize controls (for logging) ---\n        control_fits: Dict[str, Fitness] = {}\n        for nme, ts in ctrl_totals.items():\n            wr = ctrl_wins[nme] / max(1, games_per_eval)\n            count = len(ts)\n            med = float(stats.median(ts)) if count else 0.0\n            q1, q3 = _quartiles(ts) if count else (0.0, 0.0)\n            mean = (sum(ts) / count) if count else 0.0\n            sd = stats.pstdev(ts) if count > 1 else 0.0\n            mx = int(ctrl_max[nme]) if count else 0\n            mn = int(ctrl_min[nme]) if (ctrl_min[nme] is not None) else 0\n            rounds = ctrl_rounds_played[nme]\n            br = (ctrl_bust_rounds[nme] / rounds) if rounds else 0.0\n            iqr = q3 - q1\n\n            control_fits[nme] = Fitness(\n                win_rate=wr,\n                median=med,\n                q1=q1,\n                q3=q3,\n                max_score=mx,\n                min_score=mn,\n                diagnostics={\n                    \"mean\": mean,\n                    \"sd\": sd,\n                    \"iqr\": iqr,\n                    \"bust_rate\": br,\n                    \"n_games\": count,\n                }\n            )\n\n        return fits, control_fits\n"
    },
    {
      "path": "ga/ga_genome.py",
      "content": "# ga_genome.py\nimport copy, json, hashlib\nfrom typing import Any, Dict, List, Optional\nfrom evo_io import DEFAULT_GENOME\nfrom .ga_bounds import iter_paths, get_holder, clamp_to_bounds\n\n\nclass Genome:\n    \"\"\"\n    Genome wrapper around the DEFAULT_GENOME structure with a stable hash id.\n\n    Runner-compat additions:\n      • .uid  -> alias of .id\n      • .default() -> alias of .from_default()\n    \"\"\"\n    def __init__(self, data: Dict[str, Any] | None = None):\n        self.data: Dict[str, Any] = copy.deepcopy(data if data is not None else DEFAULT_GENOME)\n        self.parent_ids: Optional[List[str]] = None  # set by GA runner if desired\n\n    # Stable id computed from payload (updates automatically if payload changes)\n    @property\n    def id(self) -> str:\n        s = json.dumps(self.data, sort_keys=True, separators=(\",\", \":\"))\n        return hashlib.blake2s(s.encode(\"utf-8\"), digest_size=8).hexdigest()\n\n    # Runner-friendly alias\n    @property\n    def uid(self) -> str:\n        return self.id\n\n    @classmethod\n    def from_default(cls) -> \"Genome\":\n        return cls(copy.deepcopy(DEFAULT_GENOME))\n\n    # Runner-friendly alias\n    @classmethod\n    def default(cls) -> \"Genome\":\n        return cls.from_default()\n\n    def clone(self) -> \"Genome\":\n        return Genome(copy.deepcopy(self.data))\n\n    def paths(self) -> List[str]:\n        return iter_paths(self.data)\n\n    def get_holder(self, path: str):\n        return get_holder(self.data, path)\n\n    def clamp_all(self) -> None:\n        for p in self.paths():\n            holder, key = self.get_holder(p)\n            holder[key] = clamp_to_bounds(p, holder[key])\n\n    def to_json(self) -> Dict[str, Any]:\n        return copy.deepcopy(self.data)\n\n    @staticmethod\n    def from_json(d: Dict[str, Any]) -> \"Genome\":\n        return Genome(copy.deepcopy(d))\n"
    },
    {
      "path": "ga/ga_mutation.py",
      "content": "# ga_mutation.py\nimport copy, random\nfrom .ga_types import MutateParams\nfrom .ga_bounds import iter_paths, get_holder, clamp_to_bounds, range_for\nfrom .ga_genome import Genome\n\n\nclass Mutator:\n    \"\"\"\n    Gaussian-within-bounds mutator.\n\n    Runner-compat change:\n      • mutate(self, genome, rng=None, **kwargs) accepts an optional RNG supplied by the runner.\n        If not provided, falls back to a seed-based local RNG or global random.\n    \"\"\"\n    def __init__(self, params: MutateParams):\n        self.params = params\n\n    def mutate(self, genome: Genome, rng: random.Random | None = None, **kwargs) -> Genome:\n        rnd = rng or (random.Random(self.params.seed) if self.params.seed is not None else random)\n        child = genome.clone()\n        for path in iter_paths(child.data):\n            holder, key = get_holder(child.data, path)\n            val = holder[key]\n            if not isinstance(val, (int, float)):\n                continue\n            if rnd.random() > self.params.per_gene_prob:\n                continue\n\n            lo, hi = range_for(path)\n            span = hi - lo if hi > lo else 1.0\n\n            # Reset to random within bounds\n            if rnd.random() < self.params.reset_prob:\n                holder[key] = clamp_to_bounds(path, lo + rnd.random() * span)\n                continue\n\n            # Gaussian jitter scaled by bounds span\n            sigma = self.params.sigma_frac * span\n            holder[key] = clamp_to_bounds(path, val + rnd.gauss(0.0, sigma))\n\n        return child\n"
    },
    {
      "path": "ga/ga_repository.py",
      "content": "# ga_repository.py\nimport os, json, datetime\nfrom typing import Dict, Any\nfrom .ga_types import Fitness\n\nclass BotRepository:\n    def __init__(self, root: str = \"bots\"):\n        self.root = root\n        os.makedirs(self.root, exist_ok=True)\n        self.manifest_path = os.path.join(self.root, \"manifest.csv\")\n        if not os.path.exists(self.manifest_path):\n            with open(self.manifest_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(\"timestamp,generation,median,win_rate,max,min,bust_rate,mean,sd,seed,filename\\n\")\n\n    def save_best(self, genome_dict: Dict[str, Any], fitness: Fitness, gen_idx: int, eval_seed: int) -> str:\n        ts = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        fname = f\"gen{gen_idx:03d}_med{fitness.median:.2f}_win{int(100*fitness.win_rate):02d}_max{fitness.max_score}_min{fitness.min_score}_{ts}.json\"\n        fpath = os.path.join(self.root, fname)\n        payload = {\n            \"meta\": {\n                \"generation\": gen_idx,\n                \"timestamp\": ts,\n                \"eval_seed\": eval_seed,\n                \"fitness\": {\n                    \"median\": fitness.median,\n                    \"win_rate\": fitness.win_rate,\n                    \"max_score\": fitness.max_score,\n                    \"min_score\": fitness.min_score,\n                    \"bust_rate\": fitness.diagnostics.get(\"bust_rate\"),\n                    \"mean\": fitness.diagnostics.get(\"mean\"),\n                    \"sd\": fitness.diagnostics.get(\"sd\"),\n                }\n            },\n            \"genome\": genome_dict\n        }\n        with open(fpath, \"w\", encoding=\"utf-8\") as f:\n            json.dump(payload, f, indent=2)\n\n        with open(self.manifest_path, \"a\", encoding=\"utf-8\") as f:\n            f.write(\",\".join([\n                ts,\n                str(gen_idx),\n                f\"{fitness.median:.2f}\",\n                f\"{fitness.win_rate:.4f}\",\n                str(fitness.max_score),\n                str(fitness.min_score),\n                f\"{fitness.diagnostics.get('bust_rate', 0.0):.4f}\",\n                f\"{fitness.diagnostics.get('mean', 0.0):.4f}\",\n                f\"{fitness.diagnostics.get('sd', 0.0):.4f}\",\n                str(eval_seed),\n                fname\n            ]) + \"\\n\")\n        return fpath\n"
    },
    {
      "path": "ga/ga_runner.py",
      "content": "from __future__ import annotations\n\nimport random\nimport time\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional, Tuple, Iterable\n\nfrom .ga_types import GARunConfig, Fitness\nfrom .ga_genome import Genome\nfrom .ga_mutation import Mutator\nfrom .ga_crossover import CrossoverOperator\nfrom .ga_evaluator import PopulationEvaluator\nfrom .ga_controls import ControlPool\n\n# -------------------------------\n# ANSI colors\n# -------------------------------\n\nCOLORS = {\n    \"HEADER\": \"\\033[95m\",\n    \"BLUE\": \"\\033[94m\",\n    \"CYAN\": \"\\033[96m\",\n    \"GREEN\": \"\\033[92m\",\n    \"YELLOW\": \"\\033[93m\",\n    \"RED\": \"\\033[91m\",\n    \"BOLD\": \"\\033[1m\",\n    \"UNDERLINE\": \"\\033[4m\",\n    \"END\": \"\\033[0m\",\n}\n\ndef color_text(text: str, color: str = \"GREEN\", bold: bool = False) -> str:\n    style = COLORS[\"BOLD\"] if bold else \"\"\n    return f\"{style}{COLORS.get(color,'')}{text}{COLORS['END']}\"\n\n# -------------------------------\n# Utilities\n# -------------------------------\n\ndef short(uid: str, n: int = 8) -> str:\n    return uid[:n]\n\ndef _extract_diag(f: Fitness) -> Tuple[float, float, float, float, float]:\n    \"\"\"\n    Returns (median, q1, q3, sd, bust_rate) from Fitness.diagnostics,\n    with robust fallbacks to older key names.\n    \"\"\"\n    d = f.diagnostics or {}\n    med = float(d.get(\"median\", d.get(\"median_observed\", 0.0)))\n    q1  = float(d.get(\"q1\",     d.get(\"Q1\", 0.0)))\n    q3  = float(d.get(\"q3\",     d.get(\"Q3\", 0.0)))\n    sd  = float(d.get(\"sd\",     d.get(\"stdev\", 0.0)))\n    bust= float(d.get(\"bust_rate\", d.get(\"bust%\", 0.0)))\n    return med, q1, q3, sd, bust\n\ndef _score_key(f: Fitness) -> Tuple:\n    \"\"\"\n    Sort: win_rate (desc), median (desc), Q1(desc), Q3(desc).\n    \"\"\"\n    med, q1, q3, _, _ = _extract_diag(f)\n    return (-f.win_rate, -med, -q1, -q3)\n\ndef _relative_factor(x: float, baseline: float) -> float:\n    return (x / baseline) if baseline > 0 else 0.0\n\n# -------------------------------\n# GA Runner\n# -------------------------------\n\n@dataclass\nclass RunnerDeps:\n    evaluator: PopulationEvaluator\n    mutator: Mutator\n    crosser: CrossoverOperator\n    controls: ControlPool\n\nclass GARunner:\n    \"\"\"\n    Selection → reproduction → evaluation with colorful, detailed reporting.\n\n    API is unchanged vs your current code:\n        runner = GARunner(cfg, deps)\n        best_genome, best_fitness = runner.evolve()\n\n    Improvements:\n      • Colored population table (win%, Q1/Median/Q3, IQR, SD, bust%).\n      • Reproduction summary w/ parentage preview.\n      • Control bots section with baseline multiplier (× vs avg control win%).\n      • Mixed Top-10 leaderboard (genomes + controls).\n    \"\"\"\n\n    def __init__(self, cfg: GARunConfig, deps: RunnerDeps):\n        self.cfg = cfg\n        self.evaluator = deps.evaluator\n        self.mutator = deps.mutator\n        self.crosser = deps.crosser\n        self.controls = deps.controls\n\n        # Filled each generation for logging parentage:\n        self._last_parent_map: Dict[str, Tuple[str, str]] = {}\n\n        seed = cfg.seed if hasattr(cfg, \"seed\") else getattr(cfg, \"eval_seed\", None)\n        self._rng = random.Random(seed) if seed is not None else random\n\n    # ------------- Public -------------\n\n    def evolve(self, init_pop: Optional[List[Genome]] = None) -> Tuple[Genome, Fitness]:\n        t0 = time.time()\n\n        pop = self._init_population(init_pop)\n        print(color_text(\"\\n=== INITIAL POPULATION ===\", \"HEADER\", bold=True))\n        pop_f, ctrl_f, t_eval = self._evaluate(pop, gen_idx=0)\n        self._print_population_stats(pop, pop_f, ctrl_f, header=None)\n        self._print_controls(ctrl_f)\n        self._print_top10_summary(pop, pop_f, ctrl_f)\n        print(color_text(f\"[Timing] init evaluation={t_eval:.2f}s | total={time.time()-t0:.2f}s\\n\", \"BLUE\"))\n\n        best_idx = self._argmin_by(pop_f, key=_score_key)  # argmin because key returns negatives\n        best = pop[best_idx]\n        best_fit = pop_f[best_idx]\n\n        # Generations\n        for gen in range(1, self.cfg.generations + 1):\n            tg0 = time.time()\n\n            # Selection + reproduction\n            tsel0 = time.time()\n            elites_idx = self._select_elites(pop_f, self.cfg.elitism)\n            t_selection = time.time() - tsel0\n\n            trep0 = time.time()\n            pop = self._reproduce(pop, pop_f, elites_idx)  # updates self._last_parent_map\n            t_repro = time.time() - trep0\n\n            # Evaluate new pop\n            pop_f, ctrl_f, t_eval = self._evaluate(pop, gen_idx=gen)\n\n            # Track best\n            gen_best_idx = self._argmin_by(pop_f, key=_score_key)\n            if _score_key(pop_f[gen_best_idx]) < _score_key(best_fit):\n                best = pop[gen_best_idx]\n                best_fit = pop_f[gen_best_idx]\n\n            # Logging\n            print(color_text(f\"=== Generation {gen}/{self.cfg.generations} ===\\n\", \"HEADER\", bold=True))\n            self._print_population_stats(pop, pop_f, ctrl_f)\n            self._print_reproduction_summary(len(elites_idx), len(pop) - len(elites_idx))\n            self._print_parentage(self._last_parent_map)\n            self._print_controls(ctrl_f)\n            self._print_top10_summary(pop, pop_f, ctrl_f)\n\n            print(color_text(\n                f\"[Timing] gen{gen} selection={t_selection:.2f}s | reproduction={t_repro:.2f}s | \"\n                f\"evaluation={t_eval:.2f}s | total={time.time()-tg0:.2f}s\\n\",\n                \"BLUE\",\n            ))\n\n        return best, best_fit\n\n    # ------------- Core steps -------------\n\n    def _init_population(self, init_pop: Optional[List[Genome]]) -> List[Genome]:\n        if init_pop is not None and len(init_pop) > 0:\n            return list(init_pop)\n\n        P = getattr(self.cfg, \"population_size\", None) or getattr(self.cfg, \"pop_size\")\n        pop: List[Genome] = []\n        base = Genome.default() if hasattr(Genome, \"default\") else Genome()\n        for _ in range(P):\n            g = self.mutator.mutate(base.clone(), rng=self._rng)  # use runner RNG to diversify\n            pop.append(g)\n        return pop\n\n    def _evaluate(self, pop: List[Genome], gen_idx: int) -> Tuple[List[Fitness], Dict[str, Fitness], float]:\n        t0 = time.time()\n        games_per = getattr(self.cfg, \"games_per_eval\", 1000)\n        seed_base = (getattr(self.cfg, \"seed\", None) or getattr(self.cfg, \"eval_seed\", 0)) + gen_idx * 10_000\n        verbose = getattr(self.cfg, \"verbose_game\", 0)\n        fits, ctrl = self.evaluator.evaluate_all_in_one(\n            pop=pop,\n            games_per_eval=games_per,\n            base_seed=seed_base,\n            verbose_game=verbose,\n        )\n        return fits, ctrl, (time.time() - t0)\n\n    def _select_elites(self, fits: List[Fitness], k: int) -> List[int]:\n        idxs = list(range(len(fits)))\n        idxs.sort(key=lambda i: _score_key(fits[i]))\n        return idxs[:max(0, min(k, len(fits)))]\n\n    def _tournament(self, pop: List[Genome], fits: List[Fitness], k: int) -> int:\n        pool = self._rng.sample(range(len(pop)), k)\n        pool.sort(key=lambda i: _score_key(fits[i]))\n        return pool[0]\n\n    def _reproduce(self, pop: List[Genome], fits: List[Fitness], elite_idx: List[int]) -> List[Genome]:\n        P = len(pop)\n        E = len(elite_idx)\n        T = getattr(self.cfg, \"tournament_size\", getattr(self.cfg, \"tourney_size\", 8))\n\n        new_pop: List[Genome] = []\n        parent_map: Dict[str, Tuple[str, str]] = {}\n\n        # Elites\n        for i in elite_idx:\n            elite_clone = pop[i].clone() if hasattr(pop[i], \"clone\") else Genome.from_json(pop[i].to_json())\n            new_pop.append(elite_clone)\n            parent_map[getattr(elite_clone, \"uid\", elite_clone.id)] = (\n                getattr(pop[i], \"uid\", pop[i].id),\n                getattr(pop[i], \"uid\", pop[i].id),\n            )\n\n        # Children\n        needed = P - E\n        for _ in range(needed):\n            p1_idx = self._tournament(pop, fits, T)\n            p2_idx = self._tournament(pop, fits, T)\n            parent1 = pop[p1_idx]\n            parent2 = pop[p2_idx]\n\n            child = self.crosser.crossover(parent1, parent2, rng=self._rng) \\\n                if hasattr(self.crosser, \"crossover\") else parent1.clone()\n            child = self.mutator.mutate(child, rng=self._rng)\n\n            parent_map[getattr(child, \"uid\", child.id)] = (\n                getattr(parent1, \"uid\", parent1.id),\n                getattr(parent2, \"uid\", parent2.id),\n            )\n            new_pop.append(child)\n\n        self._last_parent_map = parent_map\n        return new_pop\n\n    # ------------- Logging -------------\n\n    def _print_population_stats(\n        self,\n        pop: List[Genome],\n        fits: List[Fitness],\n        ctrl_fits: Dict[str, Fitness],\n        header: Optional[str] = None\n    ) -> None:\n        if header:\n            print(color_text(f\"=== {header} ===\\n\", \"HEADER\", bold=True))\n\n        print(color_text(\"Population Statistics:\", \"BLUE\", bold=True))\n        order = list(range(len(pop)))\n        order.sort(key=lambda i: _score_key(fits[i]))\n        for rank, i in enumerate(order, 1):\n            tag = color_text(\"[ELITE]\", \"GREEN\") if rank <= getattr(self.cfg, \"elitism\", 0) else color_text(\"[CHILD]\", \"CYAN\")\n            f = fits[i]\n            med, q1, q3, sd, bust = _extract_diag(f)\n\n            win_color  = \"GREEN\" if f.win_rate >= 0.05 else (\"YELLOW\" if f.win_rate >= 0.03 else \"RED\")\n            bust_color = \"RED\" if bust > 0.55 else (\"YELLOW\" if bust > 0.45 else \"GREEN\")\n\n            print(\n                f\" {rank:2d}. {tag} id={color_text(short(getattr(pop[i],'uid', pop[i].id)), 'CYAN')} \"\n                f\"win%={color_text(f'{f.win_rate*100:.2f}%', win_color)} | \"\n                f\"med={color_text(f'{med:.2f}', 'CYAN')} [Q1={color_text(f'{q1:.2f}','CYAN')} | \"\n                f\"Q3={color_text(f'{q3:.2f}','CYAN')} | IQR={color_text(f'{(q3-q1):.2f}','CYAN')}] \"\n                f\"± {sd:.2f} | bust%={color_text(f'{bust*100:.2f}%', bust_color)}\"\n            )\n        print()\n\n    def _print_reproduction_summary(self, elites: int, children: int) -> None:\n        print(color_text(\"Reproduction Summary:\", \"BLUE\", bold=True))\n        print(f\"Elites carried over: {color_text(str(elites), 'GREEN')}\")\n        print(f\"New children created: {color_text(str(children), 'CYAN')}\")\n        print(f\"Genomes eliminated: {color_text(str(children - elites if children >= elites else 0), 'RED')}\")\n        print()\n\n    def _print_parentage(self, parent_map: Dict[str, Tuple[str, str]]) -> None:\n        print(color_text(\"Parent-Child Relationships:\", \"BLUE\", bold=True))\n        lines = []\n        for cid, (p1, p2) in parent_map.items():\n            lines.append(f\"{color_text(short(cid),'CYAN')} ← {color_text(short(p1),'YELLOW')}, {color_text(short(p2),'YELLOW')}\")\n        if not lines:\n            print(\"(none)\")\n        else:\n            for ln in lines[: max(5, min(20, len(lines)))]:\n                print(ln)\n        print()\n\n    def _print_controls(self, ctrl: Dict[str, Fitness]) -> None:\n        # Baseline for “×” factor: average of all controls’ win%\n        base = (sum(f.win_rate for f in ctrl.values()) / max(1, len(ctrl))) if ctrl else 0.025\n        print(color_text(\"Control Bots Performance:\", \"BLUE\", bold=True))\n        for name, f in ctrl.items():\n            med, q1, q3, sd, bust = _extract_diag(f)\n            x = _relative_factor(f.win_rate, base)\n            bust_color = \"RED\" if bust > 0.55 else (\"YELLOW\" if bust > 0.45 else \"GREEN\")\n            print(\n                f\"  {color_text(name, 'BLUE')}: \"\n                f\"win%={color_text(f'{f.win_rate*100:.2f}%', 'GREEN')} ({color_text(f'{x:.2f}×', 'GREEN' if x>=1.0 else 'RED')}) | \"\n                f\"med={color_text(f'{med:.2f}','CYAN')} [Q1={color_text(f'{q1:.2f}','CYAN')} | Q3={color_text(f'{q3:.2f}','CYAN')} | \"\n                f\"IQR={color_text(f'{(q3-q1):.2f}','CYAN')}] | bust%={color_text(f'{bust*100:.2f}%', bust_color)}\"\n            )\n        print()\n\n    def _print_top10_summary(self, pop: List[Genome], fits: List[Fitness], ctrl: Dict[str, Fitness]) -> None:\n        items: List[Tuple[str, str, str, Fitness]] = []  # (kind, label, uid, fit)\n        for g, f in zip(pop, fits):\n            items.append((\"GEN\", f\"G:{short(getattr(g,'uid', g.id))}\", getattr(g,'uid', g.id), f))\n        for name, f in ctrl.items():\n            items.append((\"CTRL\", name, name, f))\n        items.sort(key=lambda x: _score_key(x[3]))\n\n        base = (sum(f.win_rate for f in ctrl.values()) / max(1, len(ctrl))) if ctrl else 0.025\n\n        print(color_text(\"=== SUMMARY: Top 10 (Genomes + Controls) ===\", \"HEADER\", bold=True))\n        for rank, (kind, label, _, f) in enumerate(items[:10], 1):\n            med, q1, q3, sd, bust = _extract_diag(f)\n            x = _relative_factor(f.win_rate, base)\n            win_color  = \"GREEN\" if f.win_rate >= 0.05 else (\"YELLOW\" if f.win_rate >= 0.03 else \"RED\")\n            bust_color = \"RED\" if bust > 0.55 else (\"YELLOW\" if bust > 0.45 else \"GREEN\")\n            print(\n                f\" {rank:2d}. [{kind}] {color_text(label,'CYAN')}: \"\n                f\"win%={color_text(f'{f.win_rate*100:.2f}%', win_color)} ({color_text(f'{x:.2f}×','GREEN' if x>=1 else 'RED')}) | \"\n                f\"med={color_text(f'{med:.2f}','CYAN')} [Q1={color_text(f'{q1:.2f}','CYAN')} | Q3={color_text(f'{q3:.2f}','CYAN')} | \"\n                f\"IQR={color_text(f'{(q3-q1):.2f}','CYAN')}] | ± {sd:.2f} | bust%={color_text(f'{bust*100:.2f}%', bust_color)}\"\n            )\n        print()\n\n    # ------------- helpers -------------\n\n    @staticmethod\n    def _argmin_by(xs: Iterable, key):\n        best_i = None\n        best_k = None\n        for i, x in enumerate(xs):\n            k = key(x)\n            if best_i is None or k < best_k:\n                best_i, best_k = i, k\n        return best_i\n"
    },
    {
      "path": "ga/ga_selection.py",
      "content": "# ga_selection.py\nimport copy, random\nfrom typing import List, Tuple, Dict, Any, Optional\nfrom .ga_types import Fitness\n\nclass FitnessComparator:\n    def __init__(self, median_tol: float = 0.2, win_tol: float = 0.005):\n        self.median_tol = median_tol\n        self.win_tol = win_tol\n\n    def better(self, a: Fitness, b: Fitness) -> bool:\n        if abs(a.median - b.median) > self.median_tol:\n            return a.median > b.median\n        if abs(a.win_rate - b.win_rate) > self.win_tol:\n            return a.win_rate > b.win_rate\n        if a.max_score != b.max_score:\n            return a.max_score > b.max_score\n        if a.min_score != b.min_score:\n            return a.min_score > b.min_score\n        return a.diagnostics.get(\"bust_rate\", 1.0) < b.diagnostics.get(\"bust_rate\", 1.0)\n\nclass Selector:\n    def __init__(self, comparator: FitnessComparator):\n        self.comparator = comparator\n\n    def tournament(self, pop: List[Tuple[Dict[str, Any], Fitness]],\n                   tourney_size: int = 4,\n                   k: int = 1,\n                   rng: Optional[random.Random] = None) -> List[Dict[str, Any]]:\n        rng = rng or random\n        selected: List[Dict[str, Any]] = []\n        for _ in range(k):\n            group = rng.sample(pop, tourney_size)\n            best_g, best_f = group[0]\n            for g, f in group[1:]:\n                if self.comparator.better(f, best_f):\n                    best_g, best_f = g, f\n            selected.append(copy.deepcopy(best_g))\n        return selected\n"
    },
    {
      "path": "ga/ga_timing.py",
      "content": "# ga/ga_timing.py\nimport time\nfrom typing import List, Tuple\n\nclass StopWatch:\n    def __init__(self):\n        self._marks: List[Tuple[str, float]] = []\n        self._t0 = time.perf_counter()\n\n    def tick(self, label: str) -> None:\n        self._marks.append((label, time.perf_counter()))\n\n    def split_durations(self) -> List[Tuple[str, float]]:\n        \"\"\"Return (label, seconds since previous tick) for each tick.\"\"\"\n        out: List[Tuple[str, float]] = []\n        prev = self._t0\n        for label, t in self._marks:\n            out.append((label, t - prev))\n            prev = t\n        return out\n\n    def total(self) -> float:\n        if not self._marks:\n            return 0.0\n        return self._marks[-1][1] - self._t0\n\n    def pretty_line(self, prefix: str = \"\") -> str:\n        parts = []\n        for label, dt in self.split_durations():\n            parts.append(f\"{label}={dt:.2f}s\")\n        parts.append(f\"total={self.total():.2f}s\")\n        return (prefix + \" \" if prefix else \"\") + \" | \".join(parts)\n"
    },
    {
      "path": "ga/ga_types.py",
      "content": "# ga/ga_types.py\nfrom __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom typing import Dict, Any\n\n# ------------ Hyperparameter bundles ------------\n\n@dataclass(frozen=True)\nclass MutateParams:\n    \"\"\"Mutation hyperparameters used by Mutator.\"\"\"\n    sigma_frac: float = 0.12        # stddev as fraction of each bound range\n    per_gene_prob: float = 0.35         # probability a given gene is mutated\n    reset_prob: float = 0.06            # chance to reset to random within bounds\n    seed: int | None = None             # optional: RNG seed for reproducibility\n\n@dataclass(frozen=True)\nclass CrossoverParams:\n    \"\"\"Crossover hyperparameters used by CrossoverOperator.\"\"\"\n    alpha_min: float = 0.30             # BLX/arith blend min alpha\n    alpha_max: float = 0.70             # BLX/arith blend max alpha\n    per_gene_prob: float = 0.90         # probability a given gene is crossed\n    seed: int | None = None             # optional: RNG seed for reproducibility\n\n# ------------ GA run configuration ------------\n\n@dataclass\nclass GARunConfig:\n    \"\"\"Top-level configuration for a GA run.\"\"\"\n    pop_size: int = 30\n    generations: int = 200\n    games_per_eval: int = 500\n    elitism: int = 10\n    tourney_size: int = 8\n\n    mutate_params: MutateParams = field(default_factory=MutateParams)\n    crossover_params: CrossoverParams = field(default_factory=CrossoverParams)\n    mutation_after_crossover: bool = True\n\n    eval_seed: int = 1337\n    log_every: int = 1\n\n# ------------ Fitness container ------------\n\n@dataclass\nclass Fitness:\n    \"\"\"\n    Fitness used by the GA.\n    - win_rate: primary objective.\n    - median: secondary objective.\n    - q1/q3: tertiary objectives to reward conservative/consistent performers.\n    - diagnostics: extra info (sd, iqr, mean, etc.) for logging only.\n    \"\"\"\n    win_rate: float\n    median: float\n    q1: float\n    q3: float\n    max_score: int\n    min_score: int\n    diagnostics: Dict[str, Any] = field(default_factory=dict)\n"
    },
    {
      "path": "ga/pod_evaluator.py",
      "content": "# ga/pod_evaluator.py\nfrom __future__ import annotations\nimport math, random, statistics as stats, json, copy\nfrom typing import Any, Dict, List, Tuple, Callable\n\nfrom evo_player import EvoPlayer\nfrom game import SuitsGambitGame\n\n# Fallback: we use TacticianPlayer as the \"Meta\" control.\ntry:\n    from tactician_player import TacticianPlayer as MetaPlayer\nexcept Exception:\n    from smart_player import SmartPlayer as MetaPlayer  # graceful fallback\n\n# Reuse your Fitness dataclass so the field order matches (needs q1/q3)\nfrom .ga_types import Fitness\n\n\n# ---------- helpers ----------\ndef _quartiles(values: List[int]) -> tuple[float, float]:\n    \"\"\"Return (Q1, Q3) with robust fallbacks for small n.\"\"\"\n    if not values:\n        return 0.0, 0.0\n    try:\n        qs = stats.quantiles(values, n=4, method=\"inclusive\")  # [Q1, median, Q3]\n        return float(qs[0]), float(qs[2])\n    except Exception:\n        s = sorted(values)\n        n = len(s)\n        if n == 1:\n            x = float(s[0])\n            return x, x\n        def pctl(p: float) -> float:\n            k = (n - 1) * p\n            f = math.floor(k)\n            c = math.ceil(k)\n            if f == c:\n                return float(s[f])\n            return float(s[f] + (s[c] - s[f]) * (k - f))\n        return pctl(0.25), pctl(0.75)\n\n\ndef pairwise_elo_update(\n    ratings: Dict[str, float],\n    names: List[str],\n    ranks: Dict[str, float],\n    k_factor: float = 24.0,\n) -> None:\n    \"\"\"Multi-player Elo via pairwise comparisons.\"\"\"\n    expected: Dict[Tuple[str, str], float] = {}\n    for i in range(len(names)):\n        for j in range(i + 1, len(names)):\n            a, b = names[i], names[j]\n            ra, rb = ratings[a], ratings[b]\n            ea = 1.0 / (1.0 + 10 ** ((rb - ra) / 400.0))\n            expected[(a, b)] = ea\n\n    delta: Dict[str, float] = {n: 0.0 for n in names}\n    for i in range(len(names)):\n        for j in range(i + 1, len(names)):\n            a, b = names[i], names[j]\n            if abs(ranks[a] - ranks[b]) < 1e-9:\n                sa = 0.5\n            elif ranks[a] < ranks[b]:\n                sa = 1.0\n            else:\n                sa = 0.0\n            ea = expected[(a, b)]\n            eb = 1.0 - ea\n            delta[a] += k_factor * (sa - ea)\n            delta[b] += k_factor * ((1.0 - sa) - eb)\n    for n in names:\n        ratings[n] += delta[n]\n\n\ndef rank_from_scores(scores: Dict[str, int]) -> Dict[str, float]:\n    \"\"\"1-based ranks with ties averaged (higher score is better).\"\"\"\n    items = sorted(scores.items(), key=lambda kv: kv[1], reverse=True)\n    ranks: Dict[str, float] = {}\n    i = 0\n    while i < len(items):\n        j = i\n        while j < len(items) and items[j][1] == items[i][1]:\n            j += 1\n        start_place = i + 1\n        end_place = j\n        avg_rank = (start_place + end_place) / 2.0\n        for k in range(i, j):\n            ranks[items[k][0]] = avg_rank\n        i = j\n    return ranks\n\n\ndef borda_points(rank: float, pod_size: int) -> float:\n    \"\"\"Linear rank points in [0,1]: 1st -> 1.0; last -> 0.0.\"\"\"\n    return (pod_size - rank) / (pod_size - 1)\n\n\n# Accept dict / JSON string / Genome-like objects\ndef _as_genome_dict(obj: Any) -> Dict[str, Any]:\n    if isinstance(obj, dict):\n        return copy.deepcopy(obj)\n    to_json = getattr(obj, \"to_json\", None)\n    if callable(to_json):\n        payload = to_json()\n        if isinstance(payload, dict):\n            return copy.deepcopy(payload)\n        if isinstance(payload, str):\n            return json.loads(payload)\n    data = getattr(obj, \"data\", None)\n    if isinstance(data, dict):\n        return copy.deepcopy(data)\n    raise TypeError(f\"Genome-like object not convertible to dict: {type(obj)}\")\n\n\n# ---------- evaluator ----------\nclass PodEloEvaluator:\n    \"\"\"\n    Evaluate genomes in pods of fixed size (default 5).\n    Each pod = (pod_size - 1) Evo genomes + 1 Meta control.\n    \"\"\"\n\n    def __init__(\n        self,\n        pod_size: int = 5,\n        control_factory: Callable[[str], Any] | None = None,\n        initial_elo: float = 1500.0,\n        k_factor: float = 24.0,\n    ):\n        assert pod_size >= 3, \"pod_size must be at least 3\"\n        self.pod_size = pod_size\n        self.gpp = pod_size - 1\n        self.initial_elo = initial_elo\n        self.k = k_factor\n        self.control_factory = control_factory or (lambda name: MetaPlayer(name))\n\n    def _make_pods(self, indices: List[int], rng: random.Random) -> List[List[int]]:\n        return [indices[i : i + self.gpp] for i in range(0, len(indices), self.gpp)]\n\n    def evaluate(\n        self,\n        pop: List[Any],\n        rounds: int = 100,\n        base_seed: int = 12345,\n        verbose_game: int = 0,\n    ) -> Tuple[List[Fitness], Dict[str, Fitness]]:\n        P = len(pop)\n        rng_master = random.Random(base_seed)\n\n        elo: Dict[str, float] = {f\"Evo{i}\": self.initial_elo for i in range(P)}\n        elo_meta: float = self.initial_elo\n\n        totals: List[List[int]] = [[] for _ in range(P)]\n        wins = [0 for _ in range(P)]\n        top2 = [0 for _ in range(P)]\n        ranks_accum: List[List[float]] = [[] for _ in range(P)]\n        rank_pts_sum = [0.0 for _ in range(P)]\n        bust_rounds = [0 for _ in range(P)]\n        rounds_played = [0 for _ in range(P)]\n        max_score = [0 for _ in range(P)]\n        min_score = [None for _ in range(P)]\n\n        meta_totals: List[int] = []\n        meta_wins = 0\n        meta_bust_rounds = 0\n        meta_rounds_played = 0\n        meta_max = 0\n        meta_min: int | None = None\n\n        for r in range(rounds):\n            idxs = list(range(P))\n            rng_round = random.Random(rng_master.randint(0, 2**31 - 1))\n            rng_round.shuffle(idxs)\n            pods = self._make_pods(idxs, rng_round)\n\n            for p_idx, pod in enumerate(pods):\n                players = []\n                for gi in pod:\n                    name = f\"Evo{gi}\"\n                    genome_payload = _as_genome_dict(pop[gi])\n                    players.append(EvoPlayer(name, genome=genome_payload))\n\n                while len(players) < self.gpp:\n                    players.append(self.control_factory(f\"Meta_pad{p_idx}_{len(players)}\"))\n\n                players.append(self.control_factory(f\"Meta_{r}_{p_idx}\"))\n\n                rot = (r + p_idx) % self.pod_size\n                players = players[rot:] + players[:rot]\n\n                seed = base_seed ^ (r * 1315423911 + p_idx * 2654435761)\n                game = SuitsGambitGame(players, verbose=verbose_game, seed=seed)\n                winner, results = game.play()\n\n                ranks = rank_from_scores(results)\n                rpts = {n: borda_points(ranks[n], self.pod_size) for n in ranks}\n\n                names_this_game = [p.name for p in players]\n                tmp_ratings: Dict[str, float] = {}\n                for n in names_this_game:\n                    tmp_ratings[n] = elo[n] if n.startswith(\"Evo\") else elo_meta\n\n                pairwise_elo_update(tmp_ratings, names_this_game, ranks, k_factor=self.k)\n\n                for n in names_this_game:\n                    if n.startswith(\"Evo\"):\n                        elo[n] = tmp_ratings[n]\n                    else:\n                        elo_meta = tmp_ratings[n]\n\n                name_to_idx = {f\"Evo{i}\": i for i in range(P)}\n                best_score = max(results.values())\n                uniq_ranks = sorted(set(ranks.values()))\n                second_rank = uniq_ranks[1] if len(uniq_ranks) > 1 else 1.0\n\n                for pl in players:\n                    total = results[pl.name]\n                    if not pl.name.startswith(\"Evo\"):\n                        meta_totals.append(total)\n                        meta_max = max(meta_max, total)\n                        meta_min = total if meta_min is None else min(meta_min, total)\n                        meta_rounds_played += len(pl.round_scores)\n                        meta_bust_rounds += sum(1 for s in pl.round_scores if s == 0)\n                    else:\n                        i = name_to_idx[pl.name]\n                        totals[i].append(total)\n                        max_score[i] = max(max_score[i], total)\n                        min_score[i] = total if min_score[i] is None else min(min_score[i], total)\n                        rounds_played[i] += len(pl.round_scores)\n                        bust_rounds[i] += sum(1 for s in pl.round_scores if s == 0)\n                        ranks_accum[i].append(ranks[pl.name])\n                        rank_pts_sum[i] += rpts[pl.name]\n\n                winners = [n for n, s in results.items() if s == best_score]\n                seconders = [n for n, rk in ranks.items() if abs(rk - second_rank) < 1e-9]\n                for n in winners:\n                    if n.startswith(\"Evo\"):\n                        wins[name_to_idx[n]] += 1\n                    else:\n                        meta_wins += 1\n                for n in seconders:\n                    if n.startswith(\"Evo\"):\n                        top2[name_to_idx[n]] += 1\n\n        # -- Pack genome Fitness (include q1/q3) --\n        fits: List[Fitness] = []\n        baseline_win = 1.0 / self.pod_size\n        for i in range(P):\n            ts = totals[i]\n            if not ts:\n                fits.append(Fitness(\n                    win_rate=0.0,\n                    median=0.0,\n                    q1=0.0,\n                    q3=0.0,\n                    max_score=0,\n                    min_score=0,\n                    diagnostics={\n                        \"elo\": self.initial_elo, \"mean\": 0.0, \"sd\": 0.0, \"bust_rate\": 1.0,\n                        \"rank_mean\": float('inf'), \"rank_points\": 0.0,\n                        \"lift_vs_baseline\": 0.0, \"n_games\": 0,\n                    }\n                ))\n                continue\n\n            med = float(stats.median(ts))\n            q1, q3 = _quartiles(ts)\n            mx = int(max_score[i])\n            mn = int(min_score[i]) if min_score[i] is not None else 0\n            wr = wins[i] / len(ts)\n            br = (bust_rounds[i] / rounds_played[i]) if rounds_played[i] else 1.0\n            rank_mean = sum(ranks_accum[i]) / len(ranks_accum[i]) if ranks_accum[i] else float('inf')\n            rank_pts_mean = rank_pts_sum[i] / len(ts)\n            mean_total = sum(ts) / len(ts)\n            sd_total = stats.pstdev(ts) if len(ts) > 1 else 0.0\n            lift = (wr / baseline_win) if baseline_win > 0 else 0.0\n\n            fits.append(Fitness(\n                win_rate=wr,\n                median=med,\n                q1=q1,\n                q3=q3,\n                max_score=mx,\n                min_score=mn,\n                diagnostics={\n                    \"elo\": elo[f\"Evo{i}\"],\n                    \"mean\": mean_total,\n                    \"sd\": sd_total,\n                    \"bust_rate\": br,\n                    \"rank_mean\": rank_mean,\n                    \"rank_points\": rank_pts_mean,\n                    \"top2_rate\": top2[i] / len(ts),\n                    \"lift_vs_baseline\": lift,\n                    \"n_games\": len(ts),\n                }\n            ))\n\n        # -- Control Fitness (Meta), also include q1/q3 --\n        if meta_totals:\n            meta_wr = meta_wins / len(meta_totals)\n            meta_med = float(stats.median(meta_totals))\n            meta_q1, meta_q3 = _quartiles(meta_totals)\n            meta_mean = sum(meta_totals) / len(meta_totals)\n            meta_sd = stats.pstdev(meta_totals) if len(meta_totals) > 1 else 0.0\n            meta_br = (meta_bust_rounds / meta_rounds_played) if meta_rounds_played else 1.0\n            control_fits = {\n                \"Meta\": Fitness(\n                    win_rate=meta_wr,\n                    median=meta_med,\n                    q1=meta_q1,\n                    q3=meta_q3,\n                    max_score=int(meta_max),\n                    min_score=int(meta_min) if meta_min is not None else 0,\n                    diagnostics={\n                        \"elo\": elo_meta,\n                        \"mean\": meta_mean,\n                        \"sd\": meta_sd,\n                        \"bust_rate\": meta_br,\n                        \"n_games\": len(meta_totals),\n                    },\n                )\n            }\n        else:\n            control_fits = {\n                \"Meta\": Fitness(\n                    win_rate=0.0,\n                    median=0.0,\n                    q1=0.0,\n                    q3=0.0,\n                    max_score=0,\n                    min_score=0,\n                    diagnostics={\n                        \"elo\": self.initial_elo, \"mean\": 0.0, \"sd\": 0.0, \"bust_rate\": 1.0, \"n_games\": 0\n                    }\n                )\n            }\n\n        return fits, control_fits\n"
    },
    {
      "path": "ga/pod_population_evaluator.py",
      "content": "# ga/pod_population_evaluator.py\nfrom __future__ import annotations\nfrom typing import List, Tuple, Dict\nfrom .ga_types import Fitness\nfrom .ga_genome import Genome\nfrom .pod_evaluator import PodEloEvaluator\n\nclass PodPopulationEvaluator:\n    \"\"\"\n    Adapter so the pod-based evaluator matches the GA runner's expected API:\n      evaluate_all_in_one(pop, games_per_eval, base_seed, verbose_game)\n    We map games_per_eval -> pod 'rounds'.\n    \"\"\"\n    def __init__(self, pod_size: int = 5, k_factor: float = 24.0):\n        self.pod_size = pod_size\n        self.k_factor = k_factor\n        self._impl = PodEloEvaluator(pod_size=pod_size, k_factor=k_factor)\n\n    def evaluate_all_in_one(\n        self,\n        pop: List[Genome],\n        games_per_eval: int = 100,   # interpreted as \"rounds\"\n        base_seed: int = 123,\n        verbose_game: int = 0,\n    ) -> Tuple[List[Fitness], Dict[str, Fitness]]:\n        rounds = max(1, int(games_per_eval))\n        fits, control = self._impl.evaluate(\n            pop=pop,\n            rounds=rounds,\n            base_seed=base_seed,\n            verbose_game=verbose_game,\n        )\n        return fits, control\n"
    },
    {
      "path": "game.py",
      "content": "# suits_gambit_game.py\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom cards import Deck\nfrom players import BasePlayer\nfrom utils import evaluate_expression, expr_string_annotated\n\nROUNDS = 5\n\nclass SuitsGambitGame:\n    def __init__(self, players: List[BasePlayer], verbose: int | bool = 0,\n                 seed: Optional[int] = None, stats: Optional[\"StatsCollector\"] = None):\n        assert len(players) >= 2, \"Need at least two players.\"\n        self.players = players\n        self.verbose = 2 if isinstance(verbose, bool) and verbose else int(verbose)\n        if seed is not None:\n            import random\n            random.seed(seed)\n        self.stats = stats\n        self._log = self._setup_logger()\n\n    def _setup_logger(self):\n        if self.verbose >= 2:\n            return lambda msg: print(msg)\n        return lambda msg: None\n\n    def _public_state(self) -> Dict[str, Any]:\n        return {\n            \"players_public\": [\n                {\"name\": p.name, \"scores\": list(p.round_scores), \"ops\": list(p.ops_between)}\n                for p in self.players\n            ],\n            \"rounds\": ROUNDS,\n            \"turn_order\": [p.name for p in self.players],\n        }\n\n    def _play_single_turn(self, player: BasePlayer, round_idx: int, public_state: Dict[str, Any]) -> Tuple[int, Optional[int]]:\n        deck = Deck()\n        deck.reset()\n        points = 0\n        pre_bust: Optional[int] = None\n        last_card = None\n        last_forbidden_suit: Optional[str] = None  # FIX: explicit init\n\n        while True:\n            # Draw new card and declare new forbidden suit\n            card = deck.draw()\n            if not card:\n                self._log(f\"  [{player.name}] deck exhausted -> auto-stop with {points}\")\n                break\n\n            self._log(f\"    draw: {card.rank}{card.suit} (rem {deck.remaining()})\")\n\n            forbidden_ctx = {\n                \"phase\": \"declare_forbidden\",\n                \"round_index\": round_idx,\n                \"public\": public_state,\n                \"info_card\": {\"rank\": card.rank, \"suit\": card.suit},\n                \"deck_remaining_by_suit\": deck.remaining_by_suit(),\n                \"last_card\": last_card,\n                \"current_points\": points,\n            }\n            forbidden_suit = player.choose_forbidden_suit(card, forbidden_ctx)\n            self._log(f\"    [{player.name}] new forbidden suit: {forbidden_suit}\")\n\n            # Bust check uses the PREVIOUS forbidden suit (applies to this draw)\n            if last_card and last_forbidden_suit is not None and card.suit == last_forbidden_suit:\n                pre_bust = points\n                self._log(f\"    -> BUST! [{player.name}] scores 0 this round.\")\n                points = 0\n                break\n\n            points += 1\n            last_card = card\n            last_forbidden_suit = forbidden_suit\n\n            # Decision to continue/stop (after at least 1 point)\n            if points >= 1:\n                decision_ctx = {\n                    \"phase\": \"draw_decision\",\n                    \"round_index\": round_idx,\n                    \"public\": public_state,\n                    \"current_points\": points,\n                    \"last_card\": {\"rank\": card.rank, \"suit\": card.suit},\n                    \"deck_remaining_by_suit\": deck.remaining_by_suit(),\n                    \"current_forbidden\": forbidden_suit,  # FIX: explicit for p_bust\n                }\n                action = player.choose_continue_or_stop(points, decision_ctx)\n                if action == \"stop\":\n                    break\n\n        self._log(f\"  [{player.name}] ends Round {round_idx} with: {points}\\n\")\n        return points, pre_bust\n\n    def _operator_pick_phase(self, round_idx: int, public_state: Dict[str, Any]):\n        self._log(f\"Operator picks between R{round_idx} & R{round_idx+1}:\")\n        previous_picks = []\n        all_scores = {p.name: list(p.round_scores) for p in self.players}\n\n        for p in self.players:\n            ctx = {\n                \"phase\": \"operator_pick\",\n                \"round_index\": round_idx,\n                \"public\": public_state,\n                \"previous_picks\": list(previous_picks),\n                \"picker\": p.name,\n            }\n            op = p.choose_operator_between_rounds(\n                my_scores=list(p.round_scores),\n                all_scores=all_scores,\n                previous_picks=list(previous_picks),\n                ctx=ctx,\n            )\n            # FIX: normalize operators — accept 'x', '×', '*'\n            if op in (\"x\", \"×\", \"*\"):\n                op = \"x\"\n            else:\n                op = \"+\"\n            p.ops_between.append(op)\n            previous_picks.append({\"player\": p.name, \"op\": op})\n            self._log(f\"  -> {p.name}: {op}\")\n\n    def play(self):\n        for p in self.players:\n            p.reset()\n            setattr(p, \"pre_bust\", [])\n\n        for r in range(1, ROUNDS + 1):\n            public_state = self._public_state()\n            self._log(f\"\\n=== Round {r} ===\")\n\n            for p in self.players:\n                score, pre_bust = self._play_single_turn(p, r, public_state)\n                p.round_scores.append(score)\n                p.pre_bust.append(pre_bust)\n\n                if self.stats and hasattr(self.stats, \"record_round\"):\n                    op_ctx = p.ops_between[r - 2] if r > 1 and len(p.ops_between) >= (r - 1) else \"+\"\n                    outcome = RoundOutcome(  # type: ignore[name-defined]\n                        player=p.name,\n                        round_idx=r,\n                        points=score,\n                        busted=(score == 0),\n                        pre_bust_streak=pre_bust,\n                        op_context=op_ctx\n                    )\n                    self.stats.record_round(outcome)\n\n            if r < ROUNDS:\n                self._operator_pick_phase(r, public_state)\n\n        results = {p.name: evaluate_expression(p.round_scores, p.ops_between) for p in self.players}\n\n        if self.verbose >= 1:\n            print(\"\\n=== FINAL ===\")\n            for p in self.players:\n                line = expr_string_annotated(p.round_scores, p.ops_between, p.pre_bust)\n                print(f\"{p.name}: {line} = {results[p.name]}\")\n\n        best = max(results.values()) if results else None\n        leaders = [n for n, v in results.items() if v == best] if best is not None else []\n        winner = leaders[0] if len(leaders) == 1 else None\n\n        return winner, results\n"
    },
    {
      "path": "game_gui.py",
      "content": "# gui_play.py\n# Pygame GUI that REUSES your existing classes:\n# - game.SuitsGambitGame (with \"forbid after every draw\" logic)\n# - players.BasePlayer\n# - your control bot MetaOne (or HandPlayer fallback)\n#\n# Run:  python gui_play.py\n\nimport sys\nimport math\nimport random\nimport pygame\n\n# ---- reuse your code ----\nfrom game import SuitsGambitGame\nfrom players import BasePlayer\nfrom cards import SUITS  # your SUITS = [\"♣\",\"♦\",\"♥\",\"♠\"]\n\n# Try to reuse your control bot(s)\nMetaBotClass = None\ntry:\n    # if you already defined MetaOne somewhere (e.g., ga_controls or a bot module), import it\n    from ga.ga_controls import MetaOne as MetaBotClass  # adjust if you keep MetaOne elsewhere\nexcept Exception:\n    try:\n        # or fallback to the HandPlayer you showed earlier\n        from smart_player import HandPlayer as MetaBotClass\n    except Exception:\n        MetaBotClass = None\n\n\n# ---------- small UI helpers ----------\nW, H = 1024, 680\nFPS = 60\nWHITE = (246, 246, 246)\nBLACK = (24, 24, 24)\nGREY = (190, 190, 190)\nDGREY = (120, 120, 120)\nBLUE = (40, 120, 220)\nGREEN = (34, 150, 90)\nRED = (200, 60, 60)\nYELLOW = (230, 180, 40)\nPURPLE = (130, 70, 200)\n\nBTN_W, BTN_H = 140, 46\n\nclass Button:\n    def __init__(self, rect, text, color, text_color=WHITE, font=None, tag=None):\n        self.rect = pygame.Rect(rect)\n        self.text = text\n        self.color = color\n        self.text_color = text_color\n        self.font = font\n        self.tag = tag\n        self.enabled = True\n\n    def draw(self, surf):\n        c = self.color if self.enabled else DGREY\n        pygame.draw.rect(surf, c, self.rect, border_radius=10)\n        if self.font:\n            label = self.font.render(self.text, True, self.text_color)\n            surf.blit(label, label.get_rect(center=self.rect.center))\n\n    def hit(self, pos):\n        return self.enabled and self.rect.collidepoint(pos)\n\n\n# ---------- Pygame UI mediator (blocking prompts) ----------\nclass PygameUI:\n    def __init__(self):\n        pygame.init()\n        pygame.display.set_caption(\"Suits Gambit — Human vs Bot\")\n        self.screen = pygame.display.set_mode((W, H))\n        self.clock = pygame.time.Clock()\n        self.font = pygame.font.SysFont(\"consolas\", 22)\n        self.big = pygame.font.SysFont(\"consolas\", 30, bold=True)\n        self.huge = pygame.font.SysFont(\"consolas\", 46, bold=True)\n\n    def _blit_text(self, txt, x, y, big=False):\n        f = self.big if big else self.font\n        img = f.render(txt, True, BLACK)\n        self.screen.blit(img, (x, y))\n\n    def _draw_frame(self, title):\n        self.screen.fill(WHITE)\n        pygame.draw.rect(self.screen, GREY, (20, 20, W-40, 80), border_radius=12, width=2)\n        self._blit_text(title, 40, 45, big=True)\n\n    def _draw_scores(self, human, bot):\n        y = 120\n        pygame.draw.rect(self.screen, GREY, (20, y, W-40, 110), border_radius=12, width=2)\n        self._blit_text(f\"You scores: {human.round_scores}\", 40, y+15)\n        self._blit_text(f\"You ops   : {human.ops_between}\", 40, y+45)\n        self._blit_text(f\"Bot scores: {bot.round_scores}\", 40, y+75)\n        self._blit_text(f\"Bot ops   : {bot.ops_between}\", 40, y+105)\n\n    def _draw_card_and_odds(self, center_text, ctx, current_forbidden=None):\n        # info card (forbidden pick) or last card (continue/stop)\n        pygame.draw.rect(self.screen, GREY, (20, 250, W-40, 160), border_radius=12, width=2)\n        self._blit_text(center_text, 40, 270, big=True)\n\n        rem_by = (ctx.get(\"deck_remaining_by_suit\") or {})\n        suits_line = \"  |  \".join([f\"{s}:{rem_by.get(s,0)}\" for s in SUITS])\n        self._blit_text(\"Deck remaining by suit: \" + suits_line, 40, 310)\n\n        if current_forbidden:\n            total_remaining = sum(rem_by.values()) or 1\n            forb_left = rem_by.get(current_forbidden, 0)\n            p_bust = forb_left / total_remaining\n            self._blit_text(f\"Current forbidden: {current_forbidden}  |  p(bust next) ≈ {p_bust:.3f}\", 40, 340)\n\n    def ask_forbidden(self, round_idx, human, bot, info_card, ctx) -> str:\n        # suit buttons\n        buttons = []\n        sx = 80\n        for s in SUITS:\n            b = Button((sx, 450, BTN_W, BTN_H), s, BLUE if s in (\"♣\",\"♠\") else RED, WHITE, self.big, tag=(\"suit\", s))\n            buttons.append(b)\n            sx += BTN_W + 20\n\n        while True:\n            for ev in pygame.event.get():\n                if ev.type == pygame.QUIT:\n                    pygame.quit()\n                    sys.exit(0)\n                if ev.type == pygame.MOUSEBUTTONDOWN and ev.button == 1:\n                    pos = ev.pos\n                    for b in buttons:\n                        if b.hit(pos):\n                            return b.tag[1]\n\n            self._draw_frame(f\"Round {round_idx}: Choose a forbidden suit for the NEXT draw\")\n            self._draw_scores(human, bot)\n            self._draw_card_and_odds(f\"Info card shown: {info_card['rank']}{info_card['suit']}\", ctx)\n            for b in buttons:\n                b.draw(self.screen)\n            pygame.display.flip()\n            self.clock.tick(FPS)\n\n    def ask_continue(self, round_idx, human, bot, ctx) -> str:\n        cont = Button((W//2 - BTN_W - 20, 450, BTN_W, BTN_H), \"Continue\", GREEN, WHITE, self.big, tag=(\"go\", \"continue\"))\n        stop = Button((W//2 + 20, 450, BTN_W, BTN_H), \"Stop\", RED, WHITE, self.big, tag=(\"go\", \"stop\"))\n        buttons = [cont, stop]\n        last = ctx.get(\"last_card\") or {}\n        last_s = f\"{last.get('rank','?')}{last.get('suit','?')}\"\n        forb = ctx.get(\"current_forbidden\")\n\n        while True:\n            for ev in pygame.event.get():\n                if ev.type == pygame.QUIT:\n                    pygame.quit()\n                    sys.exit(0)\n                if ev.type == pygame.MOUSEBUTTONDOWN and ev.button == 1:\n                    pos = ev.pos\n                    for b in buttons:\n                        if b.hit(pos):\n                            return b.tag[1]\n\n            self._draw_frame(f\"Round {round_idx}: Continue or Stop?\")\n            self._draw_scores(human, bot)\n            self._draw_card_and_odds(f\"Last card: {last_s}   |   Points so far: {ctx.get('current_points',0)}\",\n                                     ctx, current_forbidden=forb)\n            for b in buttons:\n                b.draw(self.screen)\n            pygame.display.flip()\n            self.clock.tick(FPS)\n\n    def ask_operator(self, between_text, human, bot) -> str:\n        plus = Button((W//2 - BTN_W - 20, 450, BTN_W, BTN_H), \"+\", BLUE, WHITE, self.big, tag=(\"op\", \"+\"))\n        times = Button((W//2 + 20, 450, BTN_W, BTN_H), \"×\", PURPLE, WHITE, self.big, tag=(\"op\", \"×\"))\n        buttons = [plus, times]\n\n        while True:\n            for ev in pygame.event.get():\n                if ev.type == pygame.QUIT:\n                    pygame.quit()\n                    sys.exit(0)\n                if ev.type == pygame.MOUSEBUTTONDOWN and ev.button == 1:\n                    pos = ev.pos\n                    for b in buttons:\n                        if b.hit(pos):\n                            return b.tag[1]\n\n            self._draw_frame(between_text)\n            self._draw_scores(human, bot)\n            for b in buttons:\n                b.draw(self.screen)\n            pygame.display.flip()\n            self.clock.tick(FPS)\n\n    def show_final(self, results, winner_name):\n        # Simple final screen\n        while True:\n            for ev in pygame.event.get():\n                if ev.type == pygame.QUIT:\n                    pygame.quit()\n                    sys.exit(0)\n                if ev.type == pygame.KEYDOWN and ev.key in (pygame.K_RETURN, pygame.K_SPACE):\n                    return\n\n            self.screen.fill(WHITE)\n            self._blit_text(\"=== FINAL ===\", 40, 40, big=True)\n            y = 100\n            for name, val in results.items():\n                self._blit_text(f\"{name}: {val}\", 60, y)\n                y += 36\n            self._blit_text(f\"Winner: {winner_name if winner_name else 'Tie!'}  (press Enter to close)\", 40, y+20, big=True)\n            pygame.display.flip()\n            self.clock.tick(FPS)\n\n\n# ---------- Human adapter reusing your BasePlayer ----------\nclass HumanPlayer(BasePlayer):\n    \"\"\"\n    A BasePlayer that blocks to get choices from the Pygame UI.\n    Works with your SuitsGambitGame as-is.\n    \"\"\"\n    def __init__(self, name: str, ui: PygameUI, me_ref=None, opp_ref=None):\n        super().__init__(name)\n        self.ui = ui\n        # direct references so UI can show live scores while picking\n        self._me_ref = me_ref if me_ref is not None else self\n        self._opp_ref = opp_ref\n\n    def choose_forbidden_suit(self, first_revealed, ctx):\n        # ctx contains: info_card, deck_remaining_by_suit, etc.\n        info = ctx.get(\"info_card\") or {\"rank\": \"?\", \"suit\": \"?\"}\n        r = int(ctx.get(\"round_index\", 1))\n        return self.ui.ask_forbidden(r, self._me_ref, self._opp_ref, info, ctx)\n\n    def choose_continue_or_stop(self, current_points, ctx):\n        r = int(ctx.get(\"round_index\", 1))\n        return self.ui.ask_continue(r, self._me_ref, self._opp_ref, ctx)\n\n    def choose_operator_between_rounds(self, my_scores, all_scores, previous_picks, ctx):\n        r = int(ctx.get(\"round_index\", 1))\n        return self.ui.ask_operator(f\"Pick operator between R{r} and R{r+1}\", self._me_ref, self._opp_ref)\n\n\n# ---------- Fallback Meta bot (only if none found) ----------\nclass SafeMetaFallback(BasePlayer):\n    \"\"\"A conservative bot if MetaOne/HandPlayer import fails.\"\"\"\n    def __init__(self, name=\"MetaFallback\"):\n        super().__init__(name)\n        self._forbidden = None\n\n    def choose_forbidden_suit(self, first_revealed, ctx):\n        rem = ctx.get(\"deck_remaining_by_suit\") or {}\n        if rem and all(s in rem for s in SUITS):\n            m = min(rem[s] for s in SUITS)\n            cands = [s for s in SUITS if rem[s] == m]\n            self._forbidden = random.choice(cands)\n        else:\n            self._forbidden = first_revealed.suit\n        return self._forbidden\n\n    def choose_continue_or_stop(self, current_points, ctx):\n        last_op = self.ops_between[-1] if self.ops_between else \"+\"\n        rem_by = ctx.get(\"deck_remaining_by_suit\") or {}\n        total = sum(rem_by.values()) or 1\n        forb = ctx.get(\"current_forbidden\") or self._forbidden\n        p_bust = (rem_by.get(forb, 0) / total) if forb else 0.25\n\n        if last_op == \"×\":\n            if current_points < 3 and p_bust <= 0.35:\n                return \"continue\"\n            thresh = 0.75 / (current_points + 1)\n            return \"stop\" if p_bust >= thresh else \"continue\"\n        else:\n            if current_points < 3:\n                return \"continue\"\n            thresh = 1.0 / (current_points + 1)\n            if p_bust <= 0.18:\n                return \"continue\"\n            return \"stop\" if p_bust >= thresh else \"continue\"\n\n    def choose_operator_between_rounds(self, my_scores, all_scores, previous_picks, ctx):\n        last = my_scores[-1] if my_scores else 0\n        if last == 0:\n            return \"+\"\n        return \"×\" if (last >= 5 and random.random() < 0.6) else \"+\"\n\n\ndef main():\n    ui = PygameUI()\n\n    # Build players\n    human = HumanPlayer(\"You\", ui)\n    if MetaBotClass is None:\n        bot = SafeMetaFallback(\"MetaOne\")\n    else:\n        bot = MetaBotClass(\"MetaOne\")\n\n    # Let the UI show live scores while picking\n    human._opp_ref = bot\n\n    # Run one game using your SuitsGambitGame (reused!)\n    game = SuitsGambitGame([human, bot], verbose=0, seed=random.randrange(1_000_000))\n    winner, results = game.play()\n\n    ui.show_final(results, winner)\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except SystemExit:\n        pass\n    except Exception as e:\n        print(\"GUI crashed:\", e)\n        pygame.quit()\n        raise\n"
    },
    {
      "path": "hand_player.py",
      "content": "# smart_player.py\nimport random\nfrom typing import List, Dict, Any, Optional\nfrom cards import SUITS, Card\nfrom players import BasePlayer\n\n\nclass HandPlayer(BasePlayer):\n    \"\"\"\n    HandPlayer v4 — safer forbidden suit, smarter × segments, healthier × frequency.\n\n    Forbidden suit (weighted modes):\n      - 50%: Stats mode → choose among suit(s) with FEWEST remaining (i.e., MOST revealed).\n      - 25%: Match info card suit.\n      - 25%: Pure random.\n\n    Continue/Stop (risk- & operator-aware using actual deck odds):\n      - Compute p_bust = remaining(forbidden) / remaining(deck).\n      - Under '+':\n          * Minimum target: push to at least 3 points.\n          * EV-ish threshold: continue if p_bust < 1/(points+1).\n          * Extra push when risk is very low: if p_bust <= 0.18, keep going even if threshold says stop.\n      - Under 'x':\n          * Minimum target is soft: if points < 3 and p_bust <= 0.35 → continue (avoid wasting × on a 2).\n          * General threshold: continue if p_bust < 0.80/(points+1).\n      - ±0.02 jitter to avoid being perfectly predictable.\n      - Reasonable fallback if deck stats missing.\n\n    Operator between rounds (raise × frequency sensibly):\n      - If last round == 0 → always '+' (never multiply zero).\n      - If previous op was 'x' → 25% chance to 'x' again if last_round_score ≥ 5, else 10%.\n      - Otherwise (starting a new ×-block):\n            last_round_score ≥ 5 → 60% 'x'\n            last_round_score 3–4 → 45% 'x'\n            last_round_score ≤ 2 → 30% 'x'\n    \"\"\"\n\n    def __init__(self, name: str):\n        super().__init__(name)\n        self._forbidden: Optional[str] = None\n\n    # -------- Forbidden suit (weighted modes: stats 50%, match 25%, random 25%) --------\n    def choose_forbidden_suit(self, first_revealed: Card, ctx: Dict[str, Any]) -> str:\n        r = random.random()\n        rem: Dict[str, int] = ctx.get(\"deck_remaining_by_suit\", {}) or {}\n\n        if r < 0.50 and rem and all(s in rem for s in SUITS):\n            # Stats mode: pick suit(s) with FEWEST remaining (safest to forbid)\n            min_left = min(rem[s] for s in SUITS)\n            safest = [s for s in SUITS if rem[s] == min_left]\n            choice = random.choice(safest)\n        elif r < 0.75:\n            # Match info card suit\n            choice = first_revealed.suit\n        else:\n            # Random\n            choice = random.choice(SUITS)\n\n        self._forbidden = choice\n        return choice\n\n    # -------- Continue / Stop (deck-odds + operator aware) --------\n    def choose_continue_or_stop(self, current_points: int, ctx: Dict[str, Any]) -> str:\n        # Last operator (between previous round and this one); default '+' on Round 1\n        last_op = self.ops_between[-1] if self.ops_between else \"+\"\n\n        rem_by = ctx.get(\"deck_remaining_by_suit\") or {}\n        remaining = sum(rem_by.values()) if rem_by else 0\n        forb = self._forbidden\n        n_correct = max(0, current_points - 1)\n\n        # Fallback if we somehow lack deck stats\n        if remaining <= 0 or not rem_by or forb not in rem_by:\n            if last_op == \"x\":\n                base, inc = 0.68, 0.06\n                if current_points < 3:\n                    return \"continue\"\n            else:\n                base, inc = 0.30, 0.14\n                if current_points < 3:\n                    return \"continue\"\n            stop_prob = min(0.99, base + inc * max(0, n_correct - 1))\n            return \"stop\" if random.random() < stop_prob else \"continue\"\n\n        forbidden_left = rem_by.get(forb, 0)\n        p_bust = forbidden_left / remaining if remaining > 0 else 1.0\n        jitter = random.uniform(-0.02, 0.02)\n\n        if last_op == \"x\":\n            # Don’t waste × on a tiny segment: try to reach 3 when risk allows\n            if current_points < 3 and p_bust <= 0.35:\n                return \"continue\"\n            # General × threshold (a bit braver than v3)\n            p_thresh = 0.80 / (current_points + 1)\n            return \"stop\" if p_bust >= (p_thresh + jitter) else \"continue\"\n\n        else:\n            # Addition: push to at least 3\n            if current_points < 3:\n                return \"continue\"\n            # EV-ish threshold\n            p_thresh = 1.0 / (current_points + 1)\n            # Extra push when the shoe is very safe\n            if p_bust <= 0.18:\n                return \"continue\"\n            return \"stop\" if p_bust >= (p_thresh + jitter) else \"continue\"\n\n    # -------- Operator between rounds (score-aware × appetite) --------\n    def choose_operator_between_rounds(\n        self,\n        my_scores: List[int],\n        all_scores: Dict[str, List[int]],\n        previous_picks: List[Dict[str, str]],\n        ctx: Dict[str, Any],\n    ) -> str:\n        last_round_score = my_scores[-1] if my_scores else 0\n        if last_round_score == 0:\n            return \"+\"\n\n        prev_op = self.ops_between[-1] if self.ops_between else None\n        if prev_op == \"x\":\n            # Allow some ×→× if last was strong\n            repeat_prob = 0.25 if last_round_score >= 5 else 0.10\n            return \"x\" if random.random() < repeat_prob else \"+\"\n\n        # Starting a new ×-block: raise × usage into ~25–30%+ range overall\n        if last_round_score >= 5:\n            x_prob = 0.60\n        elif last_round_score >= 3:\n            x_prob = 0.45\n        else:\n            x_prob = 0.30\n\n        return \"x\" if random.random() < x_prob else \"+\"\n"
    },
    {
      "path": "meta_player.py",
      "content": "# meta_control_v1.py\nimport random\nfrom typing import List, Dict, Any, Optional\nfrom players import BasePlayer\nfrom cards import SUITS, Card\n\n\nclass MetaPlayer(BasePlayer):\n    \"\"\"\n    MetaPlayer — control bot tuned to your current meta (anchor-style like EvoGen019).\n\n    Key ideas:\n      • Forbidden suit: prefer STATS (fewest remaining) with smart gating; small anti-info spice.\n      • Stop policy: push to 3, selectively to 4 based on p_bust and table context; rare @5.\n      • Operator policy: ~50% × overall, but damp when leading / R5; boost when trailing/last seat.\n\n    Behavior targets:\n      • Bust rate ≈ 43–47% in mixed fields.\n      • Stops: heavy @3, selective @4, rare @5.\n      • Pairwise resilience vs additive-risky pool; doesn’t donate when leading late.\n    \"\"\"\n\n    def __init__(self, name: str):\n        super().__init__(name)\n        self._forbidden: Optional[str] = None\n\n    # ----------------- tiny helpers -----------------\n    @staticmethod\n    def _eval_expr(scores: List[int], ops: List[str]) -> int:\n        \"\"\"Evaluate scores with ops (+ or x). Fallback to sum on mismatch.\"\"\"\n        if not scores:\n            return 0\n        if not ops or len(ops) != len(scores) - 1:\n            return sum(scores)\n        total = scores[0]\n        for i in range(1, len(scores)):\n            op = ops[i - 1]\n            s = scores[i]\n            if op == \"x\":\n                total *= s\n            else:\n                total += s\n        return total\n\n    def _seat_info(self, ctx: Dict[str, Any]) -> Dict[str, Any]:\n        pub = ctx.get(\"public\") or {}\n        order: List[str] = pub.get(\"turn_order\") or []\n        try:\n            idx = order.index(self.name)\n        except ValueError:\n            idx = 0\n        n = len(order) if order else 1\n        return {\"idx\": idx, \"n\": n, \"is_first\": idx == 0, \"is_last\": idx == n - 1}\n\n    def _lead_margin(self, ctx: Dict[str, Any]) -> float:\n        pub = ctx.get(\"public\") or {}\n        entries = pub.get(\"players_public\") or []\n        my_total = 0\n        others: List[int] = []\n        for e in entries:\n            nm = e.get(\"name\")\n            sc = e.get(\"scores\") or []\n            ops = e.get(\"ops\") or []\n            tot = self._eval_expr(sc, ops)\n            if nm == self.name:\n                my_total = tot\n            else:\n                others.append(tot)\n        max_others = max(others) if others else 0\n        return float(my_total - max_others)\n\n    # ----------------- forbidden suit -----------------\n    def choose_forbidden_suit(self, first_revealed: Card, ctx: Dict[str, Any]) -> str:\n        rem: Dict[str, int] = ctx.get(\"deck_remaining_by_suit\") or {}\n        r_idx = int(ctx.get(\"round_index\", 1))\n        rounds_left = max(0, 5 - r_idx)\n        seat = self._seat_info(ctx)\n        lead = self._lead_margin(ctx)\n\n        # Base weights (stats / match / anti-info / random)\n        w_stats, w_match, w_anti, w_rand = 0.55, 0.20, 0.15, 0.10\n\n        # Gates: when trailing late or last seat with few rounds left, lean harder into stats\n        if lead < -5:\n            w_stats += 0.10\n            w_rand -= 0.05\n        if seat[\"is_last\"] and rounds_left <= 2:\n            w_stats += 0.10\n            w_match -= 0.05\n\n        # Normalize\n        tot = max(1e-9, w_stats + w_match + w_anti + w_rand)\n        w_stats, w_match, w_anti, w_rand = (w_stats / tot, w_match / tot, w_anti / tot, w_rand / tot)\n\n        u = random.random()\n        if u < w_stats and rem and all(s in rem for s in SUITS):\n            # Stats: forbid suit with FEWEST remaining (minimize p_bust)\n            m = min(rem[s] for s in SUITS)\n            safest = [s for s in SUITS if rem[s] == m]\n            choice = random.choice(safest)\n        elif u < w_stats + w_match:\n            choice = first_revealed.suit\n        elif u < w_stats + w_match + w_anti:\n            alts = [s for s in SUITS if s != first_revealed.suit] or list(SUITS)\n            choice = random.choice(alts)\n        else:\n            choice = random.choice(SUITS)\n\n        self._forbidden = choice\n        return choice\n\n    # ----------------- continue / stop -----------------\n    def choose_continue_or_stop(self, current_points: int, ctx: Dict[str, Any]) -> str:\n        last_op = self.ops_between[-1] if self.ops_between else \"+\"\n        rem_by: Dict[str, int] = ctx.get(\"deck_remaining_by_suit\") or {}\n        remaining = sum(rem_by.values()) if rem_by else 0\n        forb = self._forbidden\n\n        # Fallback if missing deck stats\n        if remaining <= 0 or not rem_by or forb not in rem_by:\n            # Conservative fallback consistent with meta (heavy @3)\n            if current_points < 3:\n                return \"continue\"\n            stop_prob = 0.55 if last_op == \"+\" else 0.62\n            return \"stop\" if random.random() < stop_prob else \"continue\"\n\n        forbidden_left = rem_by.get(forb, 0)\n        p_bust = forbidden_left / remaining if remaining > 0 else 1.0\n\n        r_idx = int(ctx.get(\"round_index\", 1))\n        seat = self._seat_info(ctx)\n        lead = self._lead_margin(ctx)\n\n        # Minimum targets: never bank at 1–2; try not to waste × below 3 if safe\n        if last_op == \"+\":\n            if current_points < 3:\n                return \"continue\"\n        else:  # 'x'\n            if current_points < 3 and p_bust <= 0.33:\n                return \"continue\"\n\n        # Base thresholds (stop if p_bust >= threshold); higher threshold = riskier (continue more)\n        if last_op == \"+\":\n            base = 0.95\n        else:\n            base = 0.78\n\n        # Context adjustments\n        # Lead/trail (per ~10 pts): trailing → raise threshold (risk more), leading → lower (risk less)\n        base += 0.06 * max(0.0, -lead / 10.0)   # trailing\n        base -= 0.06 * max(0.0, +lead / 10.0)   # leading\n\n        # Round pressure: later rounds push slightly riskier if trailing, safer if leading\n        if r_idx >= 4:\n            base += 0.04 * (1.0 if lead < 0 else -0.04)\n\n        # Last seat mild aggression when trailing and few rounds left\n        if seat[\"is_last\"] and r_idx >= 4 and lead < 0:\n            base += 0.05\n\n        # Final-round braking if holding a healthy lead\n        if r_idx == 5 and lead >= 4:\n            base -= 0.20  # more conservative at R5 with lead\n\n        # Clamp base to reasonable band\n        base = max(0.55, min(base, 1.20))\n\n        # Translate to threshold by points (@3 ≈ main decision)\n        threshold = base / (current_points + 1.0)\n\n        # Safe-shoe nudges\n        if last_op == \"+\" and p_bust <= 0.18:\n            return \"continue\"\n        if last_op == \"x\" and current_points == 3 and p_bust <= 0.28:\n            return \"continue\"\n\n        # Bank-5 bias in marginal zone (prefers banking at 5 when close)\n        jitter = random.uniform(-0.015, 0.015)\n        margin = p_bust - (threshold + jitter)\n        if current_points == 5 and -0.02 <= margin <= 0.02:\n            bias = 0.60 if last_op == \"+\" else 0.50\n            return \"stop\" if random.random() < bias else \"continue\"\n\n        return \"stop\" if p_bust >= (threshold + jitter) else \"continue\"\n\n    # ----------------- operator between rounds -----------------\n    def choose_operator_between_rounds(\n        self,\n        my_scores: List[int],\n        all_scores: Dict[str, List[int]],\n        previous_picks: List[Dict[str, str]],\n        ctx: Dict[str, Any],\n    ) -> str:\n        last_score = my_scores[-1] if my_scores else 0\n        if last_score == 0:\n            return \"+\"\n\n        r_idx = int(ctx.get(\"round_index\", 1))\n        seat = self._seat_info(ctx)\n        lead = self._lead_margin(ctx)\n\n        prev_op = self.ops_between[-1] if self.ops_between else None\n\n        # Base x appetite by last round strength (targets ~50% × over time)\n        if last_score >= 5:\n            p = 0.62\n        elif last_score >= 3:\n            p = 0.52\n        else:\n            p = 0.36\n\n        # Repeat × logic: keep heat if last was good\n        if prev_op == \"x\":\n            p = max(p, 0.55 if last_score >= 4 else 0.40)\n\n        # Context scaling (logit-ish simple deltas)\n        # Trailing → more ×; leading → less ×\n        p += 0.05 * max(0.0, -lead / 10.0)\n        p -= 0.06 * max(0.0, +lead / 10.0)\n\n        # Late-round discipline when leading; aggression when trailing & last seat\n        if r_idx == 5 and lead >= 4:\n            p -= 0.12\n        if seat[\"is_last\"] and r_idx >= 4 and lead < 0:\n            p += 0.06\n\n        # Clamp\n        p = max(0.10, min(p, 0.85))\n\n        return \"x\" if random.random() < p else \"+\"\n"
    },
    {
      "path": "players.py",
      "content": "# players.py\nfrom typing import List, Optional, Dict, Any\nfrom cards import SUITS, Card\n\nclass BasePlayer:\n    def __init__(self, name: str):\n        self.name = name\n        self.round_scores: List[int] = []\n        self.ops_between: List[str] = []\n\n    def reset(self):\n        self.round_scores.clear()\n        self.ops_between.clear()\n\n    def choose_forbidden_suit(self, first_revealed: Card, ctx: Dict[str, Any]) -> str:\n        raise NotImplementedError\n\n    def choose_continue_or_stop(self, current_points: int, ctx: Dict[str, Any]) -> str:\n        raise NotImplementedError\n\n    def choose_operator_between_rounds(\n        self,\n        my_scores: List[int],\n        all_scores: Dict[str, List[int]],\n        previous_picks: List[Dict[str, str]],\n        ctx: Dict[str, Any],\n    ) -> str:\n        raise NotImplementedError\n"
    },
    {
      "path": "random_player.py",
      "content": "import random\nfrom players import *\n\nclass RandomPlayer(BasePlayer):\n    def choose_forbidden_suit(self, first_revealed: Card, ctx: Dict[str, Any]) -> str:\n        return random.choice(SUITS)\n\n    def choose_continue_or_stop(self, current_points: int, ctx: Dict[str, Any]) -> str:\n        if current_points < 1:\n            return \"continue\"\n        return random.choice([\"continue\", \"stop\"])\n\n    def choose_operator_between_rounds(\n        self,\n        my_scores: List[int],\n        all_scores: Dict[str, List[int]],\n        previous_picks: List[Dict[str, str]],\n        ctx: Dict[str, Any],\n    ) -> str:\n        \"\"\"\n        Picks '+' or 'x' randomly, but avoids 'x' if the just-finished round score is 0.\n        \"\"\"\n        last_round_score = my_scores[-1] if my_scores else 0\n        if last_round_score == 0:\n            return \"+\"  # never multiply from 0\n        return random.choice([\"+\", \"x\"])"
    },
    {
      "path": "run.py",
      "content": "# run.py\nfrom random_player import RandomPlayer\nfrom smart_player import SmartPlayer\n\nfrom game import SuitsGambitGame\n\nif __name__ == \"__main__\":\n    # Example: 3 random bots (works with 2+ players)\n    players = [\n        RandomPlayer(\"P1\"),\n        RandomPlayer(\"P2\"),\n        SmartPlayer(\"P3\"),\n        SmartPlayer(\"P4\"),\n    ]\n\n    game = SuitsGambitGame(players, verbose=False)\n    winner, totals = game.play()\n\n    print(\"\\n--- Totals ---\")\n    for name, total in totals.items():\n        print(f\"{name}: {total}\")\n    print(f\"\\nWinner: {winner if winner is not None else 'Tie'}\")\n"
    },
    {
      "path": "smart_player.py",
      "content": "# smart_player.py\nimport random\nfrom typing import List, Dict, Any, Optional\nfrom cards import SUITS, Card\nfrom players import BasePlayer\n\nclass SmartPlayer(BasePlayer):\n    \"\"\"\n    Streaky, simple-probability bot:\n\n    - Forbidden suit: random.\n    - Continue/Stop:\n        * Must continue at ≤ 2 points.\n        * From 3+ points, stops with high and increasing probability:\n            stop_prob(3) = 0.80, then +0.30 per extra point (capped at 0.99).\n              e.g., 3→80%, 4→110%→cap to 99%, 5+→99%.\n    - Operator choice between rounds:\n        * If last round's score == 0 -> always '+' (never multiply from zero).\n        * Otherwise pick randomly, BUT if this bot's previous operator was 'x',\n          the chance to pick 'x' again is only 10% (to avoid long x-chains).\n          If previous op wasn't 'x' (or there is none), choose 50/50.\n    \"\"\"\n    def __init__(self, name: str):\n        super().__init__(name)\n        self._forbidden: Optional[str] = None\n\n    # -------- Forbidden suit --------\n    def choose_forbidden_suit(self, first_revealed: Card, ctx: Dict[str, Any]) -> str:\n        # Pure random as requested\n        choice = random.choice(SUITS)\n        self._forbidden = choice\n        return choice\n\n    # -------- Continue / Stop --------\n    def choose_continue_or_stop(self, current_points: int, ctx: Dict[str, Any]) -> str:\n        # Engine enforces the mandatory first guess, but we mirror intent here.\n        if current_points <= 2:\n            return \"continue\"\n\n        # From 3+, stop with 80% then +30% per extra point, capped at 99%\n        # 3 -> 0.80, 4 -> min(1.10, 0.99)=0.99, 5+ -> 0.99\n        extra = max(0, current_points - 3)\n        stop_prob = min(0.80 + 0.30 * extra, 0.99)\n\n        return \"stop\" if random.random() < stop_prob else \"continue\"\n\n    # -------- Operator between rounds --------\n    def choose_operator_between_rounds(\n        self,\n        my_scores: List[int],\n        all_scores: Dict[str, List[int]],\n        previous_picks: List[Dict[str, str]],\n        ctx: Dict[str, Any],\n    ) -> str:\n        # Never multiply from zero (safe-guard)\n        last_round_score = my_scores[-1] if my_scores else 0\n        if last_round_score == 0:\n            return \"+\"\n\n        # Look at this bot's own previous operator (if any)\n        prev_op = self.ops_between[-1] if self.ops_between else None\n\n        if prev_op == \"x\":\n            # After picking 'x', heavily bias away from another 'x'\n            return \"x\" if random.random() < 0.10 else \"+\"\n        else:\n            # Otherwise, pick randomly\n            return random.choice([\"+\", \"x\"])\n"
    },
    {
      "path": "stats.py",
      "content": "# run.py\nfrom random_player import RandomPlayer\nfrom smart_player import SmartPlayer\nfrom hand_player import HandPlayer\nfrom tactician_player import TacticianPlayer\n\nfrom game import SuitsGambitGame\nfrom utils import evaluate_expression\n\nimport statistics as stats\nfrom collections import defaultdict, Counter\nfrom typing import List, Dict, Tuple, Callable, Any\nimport math\n\n# =========================\n# Roster (fresh instances!)\n# =========================\ndef make_players() -> List:\n    return [\n        RandomPlayer(\"Random1\"),\n        RandomPlayer(\"Random2\"),\n        SmartPlayer(\"Smart1\"),\n        SmartPlayer(\"Smart2\"),\n        HandPlayer(\"Hand1\"),\n        HandPlayer(\"Hand2\"),\n        TacticianPlayer(\"Tac1\"),\n        TacticianPlayer(\"Tac2\"),\n    ]\n\n# =========================\n# Basic stats helpers\n# =========================\ndef iqr(values: List[float]) -> float:\n    if not values:\n        return 0.0\n    xs = sorted(values)\n    q1 = xs[len(xs)//4]\n    q3 = xs[(3*len(xs))//4]\n    return float(q3 - q1)\n\ndef wilson_ci(phat: float, n: int, z: float = 1.96) -> Tuple[float, float]:\n    if n <= 0:\n        return (0.0, 0.0)\n    center = (phat + (z*z)/(2*n)) / (1 + z*z/n)\n    margin = (z / (1 + z*z/n)) * math.sqrt((phat*(1-phat)/n) + (z*z)/(4*n*n))\n    lo = max(0.0, center - margin)\n    hi = min(1.0, center + margin)\n    return (lo, hi)\n\ndef binom_sign_test_pvalue(wins: int, n: int) -> float:\n    \"\"\"Two-sided sign test p using normal approx (fine at n>=30).\"\"\"\n    if n == 0:\n        return 1.0\n    p = 0.5\n    mu = n * p\n    sigma = math.sqrt(n * p * (1 - p))\n    z = (wins - mu) / sigma if sigma > 0 else 0.0\n    def phi(t): return 0.5 * (1 + math.erf(t / math.sqrt(2)))\n    return 2 * (1 - phi(abs(z)))\n\ndef cliffs_delta(a: List[float], b: List[float]) -> float:\n    # Pairwise (zip) variant, matches your original approach\n    gt = sum(1 for x, y in zip(a, b) if x > y)\n    lt = sum(1 for x, y in zip(a, b) if x < y)\n    n = gt + lt\n    return 0.0 if n == 0 else (gt - lt) / n\n\ndef zeroed_multiplicative_block(scores: List[int], ops: List[str]) -> bool:\n    \"\"\"True if any ×-block contains a zero (× precedence).\"\"\"\n    cur_zero = (scores[0] == 0)\n    for i, op in enumerate(ops, start=1):\n        if op == \"x\":\n            cur_zero = cur_zero or (scores[i] == 0)\n        else:  # '+'\n            if cur_zero:\n                return True\n            cur_zero = (scores[i] == 0)\n    return cur_zero\n\n# =========================\n# Sim with telemetry (extended)\n# =========================\ndef simulate(num_games: int, player_factory: Callable[[], List], game_verbose: int = 0):\n    totals_hist: Dict[str, List[int]] = defaultdict(list)\n    wins: Dict[str, int] = Counter()\n    ties = 0\n\n    bust_rounds = Counter()\n    pre_bust_sum = Counter()\n    rounds_played = Counter()\n\n    stop_at_two = Counter()\n    plus_count = Counter()\n    times_count = Counter()\n    x_after_x = Counter()\n    zeroed_block_games = Counter()\n\n    # NEW: generic stop@K stats\n    stop_counts = Counter()             # (name, K) -> count  (banked stops only)\n    stop_counts_by_op = Counter()       # (name, op, K) -> count ; op in {'+','x'}\n    stop_counts_by_round = Counter()    # (name, round_idx, K) -> count\n\n    per_game_totals: List[Dict[str, int]] = []\n\n    for _ in range(num_games):\n        players = player_factory()\n        game = SuitsGambitGame(players, verbose=game_verbose)  # keep games quiet for speed\n        winner, results = game.play()\n\n        per_game_totals.append(dict(results))\n\n        if winner is None:\n            ties += 1\n        else:\n            wins[winner] += 1\n\n        for p in players:\n            name = p.name\n            totals_hist[name].append(results[name])\n\n            # Per-round stats\n            for r, s in enumerate(p.round_scores):\n                rounds_played[name] += 1\n                # Bust tracking + pre-bust\n                if s == 0:\n                    bust_rounds[name] += 1\n                    pb = getattr(p, \"pre_bust\", [None]*5)[r]\n                    if pb is not None:\n                        pre_bust_sum[name] += pb\n                # stop@2 legacy metric\n                if s == 2:\n                    stop_at_two[name] += 1\n                # NEW: stop@K generic (only for banks)\n                if s > 0:\n                    K = s\n                    stop_counts[(name, K)] += 1\n                    # operator context for this round is op chosen between (r)->(r+1)\n                    # i.e., op BEFORE this round r+1 is p.ops_between[r-1]\n                    op_ctx = \"+\"\n                    if r > 0 and r - 1 < len(p.ops_between):\n                        op_ctx = p.ops_between[r - 1] if p.ops_between[r - 1] in (\"+\", \"x\") else \"+\"\n                    stop_counts_by_op[(name, op_ctx, K)] += 1\n                    stop_counts_by_round[(name, r + 1, K)] += 1  # rounds are 1-indexed in report\n\n            # Ops usage and patterns\n            ops = list(p.ops_between)\n            plus_count[name] += sum(1 for o in ops if o == '+')\n            times_count[name] += sum(1 for o in ops if o == 'x')\n            for a, b in zip(ops, ops[1:]):\n                if a == 'x' and b == 'x':\n                    x_after_x[name] += 1\n\n            if zeroed_multiplicative_block(p.round_scores, ops):\n                zeroed_block_games[name] += 1\n\n    return {\n        \"totals_hist\": totals_hist,\n        \"wins\": wins,\n        \"ties\": ties,\n        \"per_game_totals\": per_game_totals,\n        \"bust_rounds\": bust_rounds,\n        \"pre_bust_sum\": pre_bust_sum,\n        \"rounds_played\": rounds_played,\n        \"stop_at_two\": stop_at_two,\n        \"plus_count\": plus_count,\n        \"times_count\": times_count,\n        \"x_after_x\": x_after_x,\n        \"zeroed_block_games\": zeroed_block_games,\n        \"num_games\": num_games,\n        # NEW: extended stop stats\n        \"stop_counts\": stop_counts,                     # (name, K)\n        \"stop_counts_by_op\": stop_counts_by_op,         # (name, op, K)\n        \"stop_counts_by_round\": stop_counts_by_round,   # (name, round, K)\n    }\n\n# =========================\n# Behavior similarity\n# =========================\ndef standardize(features: Dict[str, Dict[str, float]]) -> Dict[str, Dict[str, float]]:\n    # z-score each feature across bots\n    keys = list(next(iter(features.values())).keys()) if features else []\n    out = {n: {} for n in features}\n    for k in keys:\n        vals = [features[n][k] for n in features]\n        m = sum(vals)/len(vals)\n        sd = (sum((v-m)**2 for v in vals)/len(vals))**0.5\n        for n in features:\n            out[n][k] = 0.0 if sd == 0 else (features[n][k]-m)/sd\n    return out\n\ndef behavior_distance(a: Dict[str, float], b: Dict[str, float]) -> float:\n    ks = a.keys()\n    return sum((a[k]-b[k])**2 for k in ks) ** 0.5\n\ndef behavior_features(sim: Dict[str, Any]) -> Dict[str, Dict[str, float]]:\n    names = sorted(sim[\"totals_hist\"].keys())\n    feats: Dict[str, Dict[str, float]] = {}\n    ng = sim[\"num_games\"]\n    pairs_per_game = 3  # 4 ops → 3 adjacent pairs\n    for n in names:\n        rounds = max(1, sim[\"rounds_played\"][n])\n        ops_total = sim[\"plus_count\"][n] + sim[\"times_count\"][n]\n        x_pct = sim[\"times_count\"][n] / ops_total if ops_total > 0 else 0.0\n        xchain_rate = sim[\"x_after_x\"][n] / (ng * pairs_per_game) if ng > 0 else 0.0\n        bust_rate = sim[\"bust_rounds\"][n] / rounds\n        stop2_rate = sim[\"stop_at_two\"][n] / rounds\n        zeroed_rate = sim[\"zeroed_block_games\"][n] / ng if ng > 0 else 0.0\n        scores = sim[\"totals_hist\"][n]\n        avg_pb = (sim[\"pre_bust_sum\"][n] / sim[\"bust_rounds\"][n]) if sim[\"bust_rounds\"][n] else 0.0\n        feats[n] = {\n            \"bust_rate\": bust_rate,\n            \"avg_pre_bust\": avg_pb,\n            \"stop2_rate\": stop2_rate,\n            \"x_pct\": x_pct,\n            \"xchain_rate\": xchain_rate,\n            \"zeroed_rate\": zeroed_rate,\n            \"mean_total\": stats.mean(scores),\n            \"sd_total\": stats.pstdev(scores),\n            \"median_total\": stats.median(scores),\n        }\n    return feats\n\ndef print_behavior_similarity(sim: Dict[str, Any]):\n    feats = behavior_features(sim)\n    zfeats = standardize(feats)\n    names = sorted(zfeats.keys())\n\n    # Pairwise distances + verdict\n    print(\"\\n— Behavior similarity —\")\n    SIM_THRESH = 1.20  # lower = more similar\n    similar_pairs = []\n    for i in range(len(names)):\n        for j in range(i+1, len(names)):\n            a, b = names[i], names[j]\n            d = behavior_distance(zfeats[a], zfeats[b])\n            verdict = \"SIMILAR\" if d < SIM_THRESH else \"different\"\n            print(f\"{a} vs {b}: {verdict} (dist={d:.2f})\")\n            if verdict == \"SIMILAR\":\n                similar_pairs.append((a,b))\n\n    if not similar_pairs:\n        print(\"No clearly similar pairs by behavior.\")\n    else:\n        print(\"Similar pairs:\", \", \".join([f\"{a}~{b}\" for a,b in similar_pairs]))\n\n# =========================\n# Pairwise performance\n# =========================\ndef pairwise_performance(sim: Dict[str, Any]):\n    names = sorted(sim[\"totals_hist\"].keys())\n    cols = {n: [g[n] for g in sim[\"per_game_totals\"]] for n in names}\n\n    print(\"\\n— Pairwise performance (row vs col) —\")\n    header = \" \" * 12 + \" \".join([f\"{n:>10s}\" for n in names])\n    print(header)\n    for a in names:\n        row = [f\"{a:>12s}\"]\n        for b in names:\n            if a == b:\n                row.append(f\"{'-':>10s}\")\n                continue\n            awins = sum(1 for x, y in zip(cols[a], cols[b]) if x > y)\n            aloss = sum(1 for x, y in zip(cols[a], cols[b]) if x < y)\n            n = awins + aloss\n            wr = awins / n if n else 0.0\n            row.append(f\"{100*wr:5.1f}%\")\n        print(\" \".join(row))\n\n    print(\"\\n— Pairwise sign-test p (row vs col) & Cliff’s δ —\")\n    print(header)\n    for a in names:\n        row = [f\"{a:>12s}\"]\n        for b in names:\n            if a == b:\n                row.append(f\"{'-':>10s}\")\n                continue\n            aw = sum(1 for x, y in zip(cols[a], cols[b]) if x > y)\n            al = sum(1 for x, y in zip(cols[a], cols[b]) if x < y)\n            n = aw + al\n            p = binom_sign_test_pvalue(aw, n if n else 1)\n            d = cliffs_delta(cols[a], cols[b])\n            row.append(f\"{p:6.3g}/{d:3.2f}\")\n        print(\" \".join(row))\n\n    # High-level verdicts (performance)\n    print(\"\\n— Performance verdicts —\")\n    for i in range(len(names)):\n        for j in range(i+1, len(names)):\n            a, b = names[i], names[j]\n            aw = sum(1 for x, y in zip(cols[a], cols[b]) if x > y)\n            al = sum(1 for x, y in zip(cols[a], cols[b]) if x < y)\n            n = aw + al\n            if n == 0:\n                print(f\"{a} vs {b}: no decision\")\n                continue\n            wr = aw / n\n            p = binom_sign_test_pvalue(aw, n)\n            d = abs(cliffs_delta(cols[a], cols[b]))\n            verdict = \"DIFFERENT\" if (p < 0.01 and d >= 0.10) else \"similar\"\n            print(f\"{a} vs {b}: {verdict} (wr={100*wr:.1f}%, p={p:.3g}, |δ|={d:.2f})\")\n\n# =========================\n# Helpers to print extended stop@K\n# =========================\ndef _collect_k_set(sim: Dict[str, Any], names: List[str]) -> List[int]:\n    \"\"\"Collect the set of all observed stop K across all players, sorted.\"\"\"\n    kset = set()\n    for name in names:\n        for (n, K), cnt in sim[\"stop_counts\"].items():\n            if n == name and cnt > 0:\n                kset.add(K)\n    return sorted(kset)\n\ndef _fmt_stop_row(sim: Dict[str, Any], name: str, klist: List[int]) -> str:\n    parts = []\n    for K in klist:\n        cnt = sim[\"stop_counts\"][(name, K)]\n        parts.append(f\"@{K}:{cnt:4d}\")\n    return \" \".join(parts) if parts else \"(none)\"\n\ndef _fmt_stop_by_op_row(sim: Dict[str, Any], name: str, klist: List[int], op: str) -> str:\n    parts = []\n    for K in klist:\n        cnt = sim[\"stop_counts_by_op\"][(name, op, K)]\n        parts.append(f\"@{K}:{cnt:4d}\")\n    return \" \".join(parts) if parts else \"(none)\"\n\ndef _fmt_stop_by_round_rows(sim: Dict[str, Any], name: str, klist: List[int], rounds: List[int]) -> List[str]:\n    rows = []\n    for r in rounds:\n        parts = []\n        for K in klist:\n            cnt = sim[\"stop_counts_by_round\"][(name, r, K)]\n            if cnt:\n                parts.append(f\"@{K}:{cnt:3d}\")\n        row = f\"R{r}: \" + (\" \".join(parts) if parts else \"(none)\")\n        rows.append(row)\n    return rows\n\n# =========================\n# Main report\n# =========================\ndef print_stats_report(sim: Dict[str, Any]):\n    names = sorted(sim[\"totals_hist\"].keys())\n    n_games = sim[\"num_games\"]\n\n    print(f\"\\n=== TOURNAMENT RESULTS ({n_games} games) ===\")\n\n    # Explain metrics up front\n    print(\"\\nLegend:\")\n    print(\"  mean/median/SD/IQR — distribution of FINAL totals per game\")\n    print(\"  win% — share of games with the #1 total (ties excluded)\")\n    print(\"  bust rate — % of rounds that ended at 0; avg pre-bust — typical streak before bust\")\n    print(\"  ops — count of '+' vs '×'; x→x — consecutive '×' picks; zeroed ×-block — % games where any × segment hit 0\")\n    print(\"  stop@2 — how often a round finished exactly at 2 points\")\n\n    # Per-bot summary\n    print(\"\\n— Per-bot summary —\")\n    for name in names:\n        data = sim[\"totals_hist\"][name]\n        mean = stats.mean(data)\n        med = stats.median(data)\n        sd = stats.pstdev(data)\n        mn, mx = min(data), max(data)\n        iq = iqr(data)\n        win_rate = sim[\"wins\"].get(name, 0) / n_games\n        print(f\"{name:8s} | mean {mean:6.2f} | median {med:5.1f} | sd {sd:6.2f} | IQR {iq:6.1f} | \"\n              f\"min {mn:3d} | max {mx:3d} | win% {100*win_rate:5.1f}\")\n\n    print(f\"\\nTies: {sim['ties']} ({100*sim['ties']/n_games:.1f}% of games)\")\n\n    # Behavioral stats with quick interpretations\n    print(\"\\n— Behavioral profiles —\")\n    ng = sim[\"num_games\"]\n    pairs_per_game = 3\n    for name in names:\n        r = max(1, sim[\"rounds_played\"][name])\n        busts = sim[\"bust_rounds\"][name]\n        pb_sum = sim[\"pre_bust_sum\"][name]\n        avg_pb = (pb_sum / busts) if busts else 0.0\n        stop2 = sim[\"stop_at_two\"][name]\n        plus = sim[\"plus_count\"][name]\n        times = sim[\"times_count\"][name]\n        ops_total = plus + times\n        x_pct = times/ops_total if ops_total else 0.0\n        xchain = sim[\"x_after_x\"][name] / (ng * pairs_per_game) if ng else 0.0\n        zgames = sim[\"zeroed_block_games\"][name] / ng if ng else 0.0\n\n        print(f\"{name:8s} | bust {100*busts/r:5.1f}%  | avg pre-bust {avg_pb:4.2f} | stop@2 {100*stop2/r:5.1f}% \"\n              f\"| ops: +{plus:4d} ×{times:4d} (× {100*x_pct:4.1f}%) | x→x {100*xchain:5.2f}% | zeroed ×-block {100*zgames:5.1f}%\")\n\n        # One-liner tag\n        style = []\n        style.append(\"additive-leaning\" if x_pct < 0.40 else (\"multiplier-leaning\" if x_pct > 0.60 else \"balanced ops\"))\n        style.append(\"banks early\" if stop2/r > 0.08 else \"rarely banks at 2\")\n        style.append(\"draw-risky\" if busts/r > 0.45 else (\"draw-safe\" if busts/r < 0.35 else \"draw-moderate\"))\n        print(f\"  → style: {', '.join(style)}\")\n\n    # Performance tables & verdicts\n    pairwise_performance(sim)\n\n    # Behavior similarity (based on profiles, not results)\n    print_behavior_similarity(sim)\n\n    # ========== NEW: Extended stop@K reporting ==========\n    print(\"\\n— Extended stop counts (banked rounds only) —\")\n    kset = _collect_k_set(sim, names)\n    if not kset:\n        print(\"(no banked rounds recorded)\")\n    else:\n        for name in names:\n            row = _fmt_stop_row(sim, name, kset)\n            print(f\"{name:8s} | {row}\")\n\n    print(\"\\n— stop@K by operator context —\")\n    for name in names:\n        if not kset:\n            print(f\"{name:8s} | (none)\")\n            continue\n        plus_row = _fmt_stop_by_op_row(sim, name, kset, \"+\")\n        times_row = _fmt_stop_by_op_row(sim, name, kset, \"x\")\n        # Show totals in that op context for reference\n        ops_total = sim[\"plus_count\"][name] + sim[\"times_count\"][name]\n        plus_rounds = sim[\"plus_count\"][name]  # count of '+' picks (i.e., contexts R2..R5)\n        times_rounds = sim[\"times_count\"][name]\n        print(f\"{name:8s} | '+' {plus_row}\")\n        print(f\"{'':8s} | 'x' {times_row}\")\n\n    print(\"\\n— stop@K by round —\")\n    rounds = [1, 2, 3, 4, 5]\n    for name in names:\n        rows = _fmt_stop_by_round_rows(sim, name, kset, rounds)\n        print(f\"{name:8s}\")\n        for line in rows:\n            print(f\"  {line}\")\n\n# =========================\n# Run it\n# =========================\nif __name__ == \"__main__\":\n    NUM_GAMES = 6000   # adjust as you like\n    sim = simulate(NUM_GAMES, make_players, game_verbose=0)\n    print_stats_report(sim)\n"
    },
    {
      "path": "stats_extra.py",
      "content": "# stats_extra.py\nfrom dataclasses import dataclass, field\nfrom typing import Dict, Optional, List, Tuple\nfrom collections import defaultdict\n\n\n@dataclass\nclass RoundOutcome:\n    player: str\n    round_idx: int\n    points: int                      # final round points (0 if bust)\n    busted: bool                     # True if round ended on forbidden suit\n    pre_bust_streak: Optional[int]   # points just before bust (None if not busted)\n    op_context: str                  # operator BEFORE this round: '+' or 'x'\n\n\n@dataclass\nclass StatsCollector:\n    # stop@K overall\n    stop_at_overall: Dict[int, int] = field(default_factory=dict)\n    # stop@K by operator context\n    stop_at_by_op: Dict[str, Dict[int, int]] = field(default_factory=lambda: {\"+\": {}, \"x\": {}})\n    # stop@K by round index\n    stop_at_by_round: Dict[int, Dict[int, int]] = field(default_factory=dict)\n\n    # busts\n    busts_total: int = 0\n    busts_by_round: Dict[int, int] = field(default_factory=dict)\n    # pre-bust streak histogram (1,2,3,…) counts\n    pre_bust_hist: Dict[int, int] = field(default_factory=dict)\n\n    # per-operator counters (how many rounds occurred under each op context)\n    rounds_by_op: Dict[str, int] = field(default_factory=lambda: {\"+\": 0, \"x\": 0})\n\n    # store raw outcomes if you want to post-process later\n    outcomes: List[RoundOutcome] = field(default_factory=list)\n\n    def record_round(self, outcome: RoundOutcome):\n        self.outcomes.append(outcome)\n\n        op = outcome.op_context if outcome.op_context in {\"+\", \"x\"} else \"+\"\n        self.rounds_by_op[op] += 1\n\n        if outcome.busted:\n            self.busts_total += 1\n            self.busts_by_round[outcome.round_idx] = self.busts_by_round.get(outcome.round_idx, 0) + 1\n            if outcome.pre_bust_streak:\n                self.pre_bust_hist[outcome.pre_bust_streak] = self.pre_bust_hist.get(outcome.pre_bust_streak, 0) + 1\n            return\n\n        k = outcome.points  # stopped/banked at K\n        self.stop_at_overall[k] = self.stop_at_overall.get(k, 0) + 1\n\n        if outcome.round_idx not in self.stop_at_by_round:\n            self.stop_at_by_round[outcome.round_idx] = {}\n        self.stop_at_by_round[outcome.round_idx][k] = self.stop_at_by_round[outcome.round_idx].get(k, 0) + 1\n\n        if op not in self.stop_at_by_op:\n            self.stop_at_by_op[op] = {}\n        self.stop_at_by_op[op][k] = self.stop_at_by_op[op].get(k, 0) + 1\n\n    # ---------- Summaries ----------\n    def summary_stop_overall(self) -> Dict[int, int]:\n        return dict(sorted(self.stop_at_overall.items()))\n\n    def summary_stop_by_op(self) -> Dict[str, Dict[int, int]]:\n        return {op: dict(sorted(kmap.items())) for op, kmap in self.stop_at_by_op.items()}\n\n    def summary_stop_by_round(self) -> Dict[int, Dict[int, int]]:\n        return {r: dict(sorted(kmap.items())) for r, kmap in sorted(self.stop_at_by_round.items())}\n\n    def summary_busts(self):\n        return {\n            \"total_busts\": self.busts_total,\n            \"busts_by_round\": dict(sorted(self.busts_by_round.items())),\n            \"pre_bust_hist\": dict(sorted(self.pre_bust_hist.items())),\n        }\n\n    # ---------- Pretty-printers ----------\n    def _fmt_kmap(self, kmap: Dict[int, int]) -> str:\n        if not kmap:\n            return \"{}\"\n        items = \", \".join(f\"{k}: {v}\" for k, v in sorted(kmap.items()))\n        return \"{\" + items + \"}\"\n\n    def pretty_print(self) -> str:\n        lines: List[str] = []\n        lines.append(\"=== EXTENDED ROUND-STOP & BUST METRICS ===\")\n        lines.append(\"\\n-- stop@K overall --\")\n        lines.append(self._fmt_kmap(self.summary_stop_overall()))\n\n        lines.append(\"\\n-- stop@K by operator --\")\n        for op, km in self.summary_stop_by_op().items():\n            lines.append(f\"{op}: {self._fmt_kmap(km)}  (rounds: {self.rounds_by_op.get(op,0)})\")\n\n        lines.append(\"\\n-- stop@K by round --\")\n        for rnd, km in self.summary_stop_by_round().items():\n            lines.append(f\"R{rnd}: {self._fmt_kmap(km)}\")\n\n        b = self.summary_busts()\n        lines.append(\"\\n-- busts & pre-bust --\")\n        lines.append(f\"total_busts: {b['total_busts']}\")\n        lines.append(f\"busts_by_round: {self._fmt_kmap(b['busts_by_round'])}\")\n        lines.append(f\"pre_bust_hist: {self._fmt_kmap(b['pre_bust_hist'])}\")\n\n        return \"\\n\".join(lines)\n"
    },
    {
      "path": "tactician_player.py",
      "content": "# tactician_player.py\nimport random\nfrom typing import List, Dict, Any, Optional\nfrom cards import SUITS, Card\nfrom players import BasePlayer\n\n\nclass TacticianPlayer(BasePlayer):\n    \"\"\"\n    TacticianPlayer — safer forbidden-suit logic, EV-ish draw policy, and calibrated × appetite.\n    \"\"\"\n\n    def __init__(self, name: str):\n        super().__init__(name)\n        self._forbidden: Optional[str] = None\n\n    # -------- Forbidden suit (stats 60% / match 20% / random 20%) --------\n    def choose_forbidden_suit(self, first_revealed: Card, ctx: Dict[str, Any]) -> str:\n        r = random.random()\n        rem: Dict[str, int] = ctx.get(\"deck_remaining_by_suit\") or {}\n\n        if r < 0.60 and rem and all(s in rem for s in SUITS):\n            # Stats: pick from suit(s) with FEWEST remaining (MOST revealed)\n            min_left = min(rem[s] for s in SUITS)\n            fewest = [s for s in SUITS if rem[s] == min_left]\n            choice = first_revealed.suit if first_revealed.suit in fewest else random.choice(fewest)\n        elif r < 0.80:\n            choice = first_revealed.suit\n        else:\n            choice = random.choice(SUITS)\n\n        self._forbidden = choice\n        return choice\n\n    # -------- Continue / Stop (deck-odds + operator aware) --------\n    def choose_continue_or_stop(self, current_points: int, ctx: Dict[str, Any]) -> str:\n        last_op = self.ops_between[-1] if self.ops_between else \"+\"\n\n        rem_by = ctx.get(\"deck_remaining_by_suit\") or {}\n        remaining = sum(rem_by.values()) if rem_by else 0\n        forb = self._forbidden\n        jitter = random.uniform(-0.02, 0.02)\n\n        # Fallback if stats missing\n        if remaining <= 0 or not rem_by or forb not in rem_by:\n            if last_op == \"x\":\n                if current_points < 3:\n                    return \"continue\"\n                base, inc = 0.66, 0.06\n            else:\n                if current_points < 3:\n                    return \"continue\"\n                base, inc = 0.28, 0.14\n            n_correct = max(0, current_points - 1)\n            stop_prob = min(0.99, base + inc * max(0, n_correct - 1))\n            return \"stop\" if random.random() < stop_prob else \"continue\"\n\n        forbidden_left = rem_by.get(forb, 0)\n        p_bust = forbidden_left / remaining if remaining > 0 else 1.0\n\n        if last_op == \"x\":\n            # Build × segments when safe\n            if current_points < 3 and p_bust <= 0.33:\n                return \"continue\"\n            if current_points < 4 and p_bust <= 0.15:\n                return \"continue\"\n            p_thresh = 0.85 / (current_points + 1)\n            return \"stop\" if p_bust >= (p_thresh + jitter) else \"continue\"\n\n        # '+' context\n        if current_points < 3:\n            return \"continue\"\n        if p_bust <= 0.16:\n            return \"continue\"\n        p_thresh = 0.95 / (current_points + 1)\n        return \"stop\" if p_bust >= (p_thresh + jitter) else \"continue\"\n\n    # -------- Operator between rounds (score-aware × appetite) --------\n    def choose_operator_between_rounds(\n        self,\n        my_scores: List[int],\n        all_scores: Dict[str, List[int]],\n        previous_picks: List[Dict[str, str]],\n        ctx: Dict[str, Any],\n    ) -> str:\n        last_round_score = my_scores[-1] if my_scores else 0\n        if last_round_score == 0:\n            return \"+\"\n\n        prev_op = self.ops_between[-1] if self.ops_between else None\n        if prev_op == \"x\":\n            if last_round_score >= 6:\n                repeat_prob = 0.30\n            elif last_round_score >= 4:\n                repeat_prob = 0.18\n            else:\n                repeat_prob = 0.10\n            return \"x\" if random.random() < repeat_prob else \"+\"\n\n        if last_round_score >= 6:\n            x_prob = 0.62\n        elif last_round_score >= 4:\n            x_prob = 0.48\n        else:\n            x_prob = 0.32\n\n        return \"x\" if random.random() < x_prob else \"+\"\n"
    },
    {
      "path": "time_test.py",
      "content": "# new_runner.py\nimport time\nfrom random_player import RandomPlayer\nfrom smart_player import SmartPlayer\nfrom game import SuitsGambitGame\n\ndef run_simulation(num_players, num_games=5000):\n    \"\"\"\n    Simulates a number of games for a given number of players.\n    Returns the elapsed time.\n    \"\"\"\n    start_time = time.perf_counter()\n\n    for _ in range(num_games):\n        # Create a mix of RandomPlayer and SmartPlayer instances\n        players = [RandomPlayer(f\"Random{i}\") for i in range(num_players // 2)]\n        players += [SmartPlayer(f\"Smart{i}\") for i in range(num_players - (num_players // 2))]\n\n        game = SuitsGambitGame(players, verbose=False)\n        game.play()\n\n    end_time = time.perf_counter()\n    return end_time - start_time\n\nif __name__ == \"__main__\":\n    print(\"--- Suits Gambit Game Simulation Timing ---\")\n    results = {}\n    \n    # Loop from 1 to 50 players\n    for x in range(1, 51):\n        # We need at least two players to play a game\n        if x < 2:\n            print(f\"Skipping {x} players as the game requires a minimum of 2.\")\n            continue\n\n        print(f\"Simulating 5000 games with {x} players...\")\n        elapsed_time = run_simulation(x)\n        results[x] = elapsed_time\n        print(f\"Completed in {elapsed_time:.4f} seconds.\\n\")\n\n    print(\"\\n--- Summary of Results ---\")\n    for num_players, duration in results.items():\n        print(f\"Players: {num_players:2d} | Time: {duration:.4f} seconds\")"
    },
    {
      "path": "utils.py",
      "content": "# utils.py\nfrom typing import List, Optional\n\ndef evaluate_expression(scores: List[int], ops: List[str]) -> int:\n    \"\"\"\n    Evaluate with normal precedence (× before +).\n    Example: 4 + 0 + 0 + 2 x 4  ->  4 + 0 + 0 + (2*4) = 12\n    \"\"\"\n    assert len(scores) == 5 and len(ops) == 4\n    total = 0\n    cur = scores[0]\n    for i, op in enumerate(ops, start=1):\n        if op == \"x\":\n            cur *= scores[i]\n        else:  # '+'\n            total += cur\n            cur = scores[i]\n    total += cur\n    return total\n\ndef expr_string(scores: List[int], ops: List[str]) -> str:\n    \"\"\"\n    Plain expression string without annotations.\n    \"\"\"\n    out = f\"{scores[0]}\"\n    for i, op in enumerate(ops, start=1):\n        out += f\" {op} {scores[i]}\"\n    return out\n\ndef expr_string_annotated(round_scores, operators, pre_busts):\n    \"\"\"\n    Build a string like: 0 + 2 + 4#0 + 2 + 3\n    where '4#0' means the player had 4 points before busting to 0.\n    \"\"\"\n    parts = []\n    for i, score in enumerate(round_scores):\n        if score == 0 and pre_busts[i] is not None:\n            parts.append(f\"[{pre_busts[i]}].0\")  # bust annotation\n        else:\n            parts.append(str(score))\n        if i < len(operators):\n            parts.append(operators[i])\n    return \" \".join(parts)\n\n"
    }
  ]
}